<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker入门]]></title>
    <url>%2F2019%2F03%2F27%2Fdocker%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Docker安装Mac：https://docs.docker.com/docke...Windows:https://docs.docker.com/docke...linux:官网有不同版本的安装的教程ubuntu:https://docs.docker.com/engin... Docker三个基本概念下面这张图非常的经典，很形象地展示了，什么是容器，什么是镜像，什么是仓库，以及三者之间的联系。 接下来我们来解释一下这张图。现在我们要造一间厨房，在造之前我们首先要干的一件事，就是先列举出我们造厨房需要的东西。我们可能需要一个通了水电煤的房子以及一些必需的厨房用具诸如锅碗瓢勺、煤气灶、冰箱、水槽等等这些东西。现在我们知道需要了什么东西之后，我们就去找这些东西。首先我们先去京东购买一些厨房用具，这些用具就好比我们的Docker镜像，我们厨房的用具到了之后得找个地方把它们放在，不可能随处丢吧，不然后面用的时候就找不到它了，那么我们Docker镜像也是这样，需要一个Docker仓库去存储这些镜像。现在我们有了这些厨房用具之后就可以做饭了吗？答案当然是不能，没水没电没火啊！这时候我们得把厨房用具给装到一个通了水电煤的房子才行，那么Docker镜像也是这样，单纯的Docker镜像是不能用的，它得装到Docker容器中通了水电煤才能使用。等我们装好了厨房用具之后我们就可以开始做饭，那么我们的Docker镜像装到Docker容器之后，我们应用就可以跑起来了。 Docker常用命令1.杀死所有正在运行的容器1docker kill $(docker ps -a -q) 2.删除所有已经停止的容器1docker rm $(docker ps -a -q) 3.删除所有镜像1docker rmi $(docker images -q) 4.关闭容器1docker stop CONTAINER ID或者NAMES 5.重新启动关闭的容器1docker start CONTAINER ID或者NAMES 6.移除本地容器1docker rm CONTAINER ID或者NAMES 7.查看本地容器12docker ps //查看正在运行的容器docker ps -a //查看所有容器 8.查看本地镜像1docker images 9.创建镜像1docker build -t name:tag Dockerfile路径 10.修改本地镜像标记12docker tag IMAGE ID name:tag docker rmi name:tag 11.删除本地镜像1docker rmi name:tag或者IMAGE ID 12.进入容器1docker exec -it IMAGE ID或者NAMES /bin/bash 13.获取镜像中心的镜像1docker pull name:tag 14.获取容器的端口映射配置1docker port CONTAINER ID或者NAMES]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows上利用docker搭建lnmp开发环境]]></title>
    <url>%2F2019%2F03%2F27%2Fwindows%E4%B8%8A%E5%88%A9%E7%94%A8docker%E6%90%AD%E5%BB%BAlnmp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装docker到docker官网进行安装书籍:Docker技术入门与实战 开启Hyper-V打开控制面板 - 程序和功能 - 启用或关闭Windows功能，勾选Hyper-V，然后点击确定即可，如图： 下载windwos版本docker安装包 地址 修改docker 镜像仓库安装好后登陆docker（没有账号的请到官网进行注册） 使用git快速获取lnmp切换到你准备安装dnmp的目录下 123$ git clone https://github.com/shmilylbelva/dnmp.git$ cd dnmp$ docker-compose up 完成以后可以在浏览器中访问localhost，出现界面代表ok 站点部署c:\Windows\System32\Drivers\etc\hosts 本文有默认加了两个站点：www.site1.com（同localhost）和www.site2.com。要在本地访问这两个域名，需要修改你的hosts文件，添加以下两行：127.0.0.1 www.site1.com127.0.0.1 www.site2.com其中，www.site2.com为支持SSL/https和HTTP/2的示例站点。因为站点2的SSL采用自签名方式，所以浏览器有安全提示，继续访问就可以了，自己的站点用第三方SSL认证证书替换即可。如果只用到站点1，把站点2相关的目录和配置文件删除：./conf/nginx/conf.d/certs/site2/./conf/nginx/conf.d/site2.conf./www/site2/重启容器内的Nginx生效：docker exec -it dlnmp_nginx nginx -s reload dnmp目录结构12345678910111213141516171819202122232425.├── conf 配置目录│ ├── conf.d 站点配置文件目录│ │ ├── certs SSL认证文件、密钥和加密文件目录│ │ │ └── site2 站点2的认证文件目录│ │ ├── site1.conf 站点1 Nginx配置文件│ │ └── site2.conf 站点2 Nginx配置文件 │ ├── my.cnf MySQL配置文件 │ ├── nginx.conf Nginx通用配置文件│ ├── php-fpm.d PHP-FPM配置目录│ │ └── www.conf PHP-FPM配置文件│ ├── php.ini PHP配置文件├── docker-compose.yml 默认容器启动配置文件├── docker-compose54.yml php5.4容器启动配置文件├── docker-compose56.yml php5.6容器启动配置文件├── log 日志目录│ ├── mysql.slow.log MySQL日志│ ├── nginx.error.log Nginx日志│ ├── nginx.site1.error.log │ ├── nginx.site2.error.log ├── mysql MySQL数据文件目录├── php PHP版本目录└── www 站点根目录 ├── site1 站点1根目录 └── site2 站点2根目录 MYSQL说明在docker-compose.yml文件中，我们指定了MySQL数据库root用户的密码为123456。所以，我们就可以在主机中通过： 12345$ mysql -h 127.0.0.1 -u root -p #linux中#在mac中需要先切换到mysql容器$ docker container ls #列出容器列表$ docker exec -it 775c7c9ee1e1 /bin/bash #其中的容器id不用输入完整的mysql容器id,一般3位就能区分。$ mysql -h 127.0.0.1 -uroot -p 输入密码，就可以进入MySQL命令行。 说明：这里MySQL的连接主机不能用localhost，因为MySQL客户端默认使用unix socket方式连接，应该直接用本地IP。在PHP代码中的使用方式与在主机中使用稍有不同，如下：$pdo = new PDO(‘mysql:host=mysql;dbname=site1’, ‘root’, ‘123456’);其中，host的值就是在docker-compose.yml里面指定的MySQL容器的名称。这是因为PHP代码是在FPM容器中，FPM容器启动时会自动在/etc/hosts中加上：172.17.0.2 mysql 11e55f91c4c3 dnmp_mysql就是说，mysql自动指向了MySQL容器动态生成的IP。注意，这里用php进行mysql连接测试会失败（在docker-compose up的时候注意到存在mbind:Operation not permitted 这个提示） ，所以还需要处理上述问题。进入刚刚的mysql终端,内容大致如下。host为 % 表示不限制ip localhost表示本机使用 plugin非mysql_native_password 则需要修改密码 12345678910mysql&gt; select host,user,plugin,authentication_string from mysql.user; +-----------+------------------+-----------------------+------------------------------------------------------------------------+ | host | user | plugin | authentication_string | +-----------+------------------+-----------------------+------------------------------------------------------------------------+ | % | root | caching_sha2_password | $A$005$^]RQB&#125;j~t! .#v)3.UogPRFu8VJA5/GKEbK5edEQlMT5sHw2n72zYJNlIbo3 | | localhost | mysql.infoschema | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | | localhost | mysql.session | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | | localhost | mysql.sys | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | | localhost | root | caching_sha2_password | $A$005$Y6&amp;q!59^Fmh)@-6TG58J3F5+3I/HI9L|JCadNG+-+d6W+1D_UFW+7MRD7F3 | +-----------+------------------+-----------------------+------------------------------------------------------------------------+ 依次进行如下操作 1234#更新一下用户的密码 root用户密码为newpassword mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;FLUSH PRIVILEGES; mysql连接问题解决。 修改docker-compose.yml如果容器已经生成，回头再编辑docker-compose.yml，用docker-compose up命令会直接启动原来的容器，修改的内容不会体现在启动的容器里。所以，要使修改的docker-compose.yml生效，需要以下4步： 1234$ docker stop dnmp_nginx # 第一步：停止容器$ docker rm dnmp_nginx # 第二步：删除容器# !!第三步：重启Docker服务!!$ docker-compose up -d --no-deps --build mysql # 第四步：重新启动容器 其中最后一条命令参数作用：/-d：后台执行–no-deps：不启动link的容器–build：启动容器前先构建镜像 使用RedisRedis使用和MySQL类似。不过需要注意的是在./php/php72中的Dockerfile末尾的 1234567891011#源码安装方式#php7 can installENV PHPREDIS_VERSION 4.0.0RUN curl -L -o /tmp/redis.tar.gz https://github.com/phpredis/phpredis/archive/$PHPREDIS_VERSION.tar.gz \ &amp;&amp; tar xfz /tmp/redis.tar.gz \ &amp;&amp; rm -r /tmp/redis.tar.gz \ &amp;&amp; mkdir -p /usr/src/php/ext \ &amp;&amp; mv phpredis-$PHPREDIS_VERSION /usr/src/php/ext/redis \ &amp;&amp; docker-php-ext-install redis \ &amp;&amp; rm -rf /usr/src/php 如果是php5.X那么这里应该是这样的（需要自己添加到对应的Dockerfile中，然后再docker-compose up） 123456789101112#PECL安装方式#php5 can install#添加扩展 redis pecl方式RUN apk add --no-cache --update libmemcached-libs zlibRUN set -xe \ &amp;&amp; apk add --no-cache --update --virtual .phpize-deps $PHPIZE_DEPS \ &amp;&amp; pecl install -o -f redis \ &amp;&amp; echo &quot;extension=redis.so&quot; &gt; /usr/local/etc/php/conf.d/redis.ini &amp;&amp; rm -rf /usr/share/php \ &amp;&amp; rm -rf /tmp/* \ &amp;&amp; apk del .phpize-deps 在主机和容器内部都通过地址127.0.0.1，端口6379访问。 PHP则是跨容器访问，host参数用redis（links指定的名称），端口用6379。修改site2的index.php文件内容如下 123456&lt;?php $redis = new Redis(); $redis-&gt;connect(&apos;192.168.1.11&apos;,6379);//修改成自己的ip $redis-&gt;set(&apos;name&apos;,&apos;青波&apos;); echo $redis-&gt;get(&apos;name&apos;); //检测是否连接成功 浏览器访问www.site2.com,出现‘青波’即代表redis扩展正常。 作者：回眸淡然笑链接：https://www.jianshu.com/p/31c09a3e0d5d来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写文章（基于 Markdown）]]></title>
    <url>%2F2019%2F03%2F23%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[创建文章在站点文件夹中打开 git bash，输入如下命令创建文章，其中 title 为文章的标题1$ hexo new "title" 当输入命令后，就会在 source/_post 文件夹下创建一个文件，命名为：title.md这个文件就是将要发布到网站上的原始文件，用于记录文章内容下面，我们将要在这个文件中写下我们的第一篇博客 编写文章（基于 Markdown）Markdown 简介但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？1Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式 基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言 Markdown 语法在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览这里附上 Typora 的下载地址：https://www.typora.io/ 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 粗体、斜体、删除线和下划线1234*斜体***粗体*****加粗斜体***~~删除线~~ 引用块1&gt; 文字引用 公式块123$$数学公式$$ 分割线12345方法一：---方法二：+++方法三：*** 列表12345671. 有序列表项* 无序列表项+ 无序列表项- 无序列表项 表格1234表头1|表头2-|-|-内容11|内容12内容21|内容22 超链接12345方法一：[链接文字](链接地址 "链接描述")例如：[示例链接](https://www.example.com/ "示例链接")方法二：&lt;链接地址&gt;例如：&lt;https://www.example.com/&gt; 图片12![图片文字](图片地址 "图片描述")例如：![示例图片](https://www.example.com/example.PNG "示例图片") 说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置将 站点配置文件 中的 post_asset_folder 选项的值设置为 true在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 添加图片(注意有感叹号!前面) Hexo NexT 内置标签「标签」(Tag Plugin) 是 Hexo 提供的一种快速生成特定内容的方式。例如，在标准 Markdown 语法中，我们无法指定图片的大小。这种情景，我们即可使用标签来解决。 Hexo 内置来许多标签来帮助写作者可以更快的书写，完整的标签列表 可以参考 Hexo 官网。 另外，Hexo 也开放来接口给主题，使主题有可能提供给写作者更简便的写作方法。以下标签便是 NexT 主题当前提供的标签。 文本居中的引用此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。例如作为文章开篇引用 或者 结束语之前的总结引用。 使用方式 HTML方式：使用这种方式时，给 img 添加属性 class=”blockquote-center” 即可。 标签方式：使用 centerquote 或者 简写 cq。 1此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式。 123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 突破容器宽度限制的图片当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片,图片的扩大与容器的偏差从视觉上提升图片的吸引力。 此标签有两种调用方式（详细参看底下示例）： 使用方式 HTML方式：使用这种方式时，为 img 添加属性 class=”full-image”即可。 标签方式：使用 fullimage 或者 简写 fi， 并传递图片地址、 alt 和 title 属性即可。 属性之间以逗号分隔。 12此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式。如果要在图片下显示图片的标题，请使用 标签方式 并给定 title 属性。 123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;full-image&quot; 是必须的 --&gt;&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% fullimage /image-url, alt, title %&#125;&lt;!-- 别名 --&gt;&#123;% fi /image-url, alt, title %&#125; Bootstrap Callout 由 ivan-nginx 贡献这些样式出现在 Bootstrap 的官方文档中。 使用方式1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default primary success info warning danger]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 语言入门笔记]]></title>
    <url>%2F2019%2F03%2F23%2FGo%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[工作需要入手了 Go 语言，开发使用的是 Gin Web Framework。 入手后发现语法和 PHP/Python/JavaScript 之流还是有很大区别的，下面对学习资料及入门笔记做简单整理。 简介 Go（又称 Golang ），由 Google 开发 是一种 静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言 语法接近 C 语言，但对于变量的声明有所不同 安装安装 直接前往 官网 下载 .pkg 完成安装。go中文网 一般去中文网下载 workspace用于放置一个 go 程序员的所有 go 代码和依赖。 目录结构 src：go源码文件 pkg：package object（编译出的二进制文件） bin：可执行文件（编译出的二进制文件） GOPATHworkspace 的路径，默认为 $HOME/go。 设置直接安装 .pkg 文件未设置 GOPATH，需要手动设置一下：1export GOPATH=$HOME/go 加入环境变量： 1export PATH=$PATH:$(go env GOPATH)/bin 编辑器折腾了好久别的编辑器还是用jetbrains 的 GoLand 舒服功能齐全 Hello, World入口程序入口为：main.main。 12345package mainfunc main() &#123; ...&#125; hello.go创建新项目：/Users/jjy/go/src/exampleProject，新建文件 hello.go： 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, world!&quot;)&#125; 编译在 /Users/jjy/go/src/exampleProject 下执行 go install，之后会在 $GOPATH/bin 目录下生成编译后的二进制程序。 执行12▶ /Users/jjy/go/bin/exampleProjectHello, world! 一些特性 函数多返回值 并发编程 错误处理 学习资料 官方文档 Go语言学习 - cyent笔记 awesome-go Go 入门指南]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序是怎么跑起来的]]></title>
    <url>%2F2019%2F01%2F04%2F%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%2F</url>
    <content type="text"><![CDATA[对程序员来说CPU是什么？热身1.程序是什么？2.程序是由什么组成的？3.什么是机器语言？4.正在运行的程序存储在什么位置？5.什么是内存地址？6.计算机的构成原件中，负责程序的解释和运行的是哪个？ 我的第一次回答1.计算机运行的命令2.由指令和数据组成3.计算机可以直接识别的语言4.内存5.一个位置6.CPU 答案 1.指示计算机每一步动作的一组指令2.指令和数据3.CPU可以直接识别并使用的语言4.内存5.内存中，用来表示命令和数据存储位置的数值6.CPU]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十年学会编程]]></title>
    <url>%2F2019%2F01%2F02%2F%E5%8D%81%E5%B9%B4%E5%AD%A6%E4%BC%9A%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[十年学会编程 Teach Yourself Programming in Ten YearsPeter NorviGWhy is everyone in such a rush？为何每个人都急于求成?Walk into any bookstore, and you’ll see how to Teach Yourself Java in 24 Hours alongside endless variations offering to teach C, SQL, Ruby, Algorithms, and so on in a few days or hours. The Amazon advanced search for [title: teach, yourself, hours, since: 2000 and found 512 such books. Of the top ten, nine are programming books (the other is about bookkeeping). Similar results come from replacing “teach yourself” with “learn” or “hours” with “days.” 随便走进一家书店，都会看到类似《24小时学会Java》这样的书，旁边摆着的是大量诸如在几天，几小时之内学会C语言，SQL，Ruby以及算法这样的书。如果使用Amazon上的高级搜索，使用title: teach, yourself, hours, since: 2000这个关键字来搜索，将会返回512本书。最靠前的10本书中，有9本是编程的书（唯一的例外是一本记账的书）。如果把关键字”teach yourself”替换成”learn”，或者将”hours”替换成”days”，返回的结果大同小异。 The conclusion is that either people are in a big rush to learn about programming, or that programming is somehow fabulously easier to learn than anything else. Felleisen et al. give a nod to this trend in their book How to Design Programs, when they say “Bad programming is easy. Idiots can learn it in 21 days, even if they are dummies.” The Abtruse Goose comic also had their take. 很明显，人们在学习编程的时候喜欢大跃进，或者认为编程比起其它事情来，是小菜一碟的事。Felleisen在他的书《How to Design Program》里说：“编烂程一点也不难。傻瓜也可以在21天内学会，即使他们是傻逼。”在搞笑漫画网站Abtruse Goose也在这个漫画中表达了同样的看法。 Let’s analyze what a title like Teach Yourself C++ in 24 Hours could mean: 我们来看看类似《24小时自学C++》这种标题党，到底说的什么鬼东西： Teach Yourself: In 24 hours you won’t have time to write several significant programs, and learn from your successes and failures with them. You won’t have time to work with an experienced programmer and understand what it is like to live in a C++ environment. In short, you won’t have time to learn much. So the book can only be talking about a superficial familiarity, not a deep understanding. As Alexander Pope said, a little learning is a dangerous thing.自学: 24小时之内，你没有时间写几个有意义的程序，也就无法从成功或失败中学到经验。24小时之内，你没有时间和一个有经验的程序员合作交流，也就无从理解使用C++编程的真实场景。简单来说，时间太短，你啥也学不到。因此，有这种干货标题的速成书，只是让你走马观花的瞧一下，绝非深入的理解。18世纪的英国诗人亚历山大·蒲柏[……1]曾说过：“一知半解”是一件危险的事情。[……1]：这个哥哥还给牛顿写了最出名的墓志铭之一：“自然和自然律隐没在黑暗中；上帝说，让牛顿去吧！遂一片光明。”C++: In 24 hours you might be able to learn some of the syntax of C++ (if you already know another language), but you couldn’t learn much about how to use the language. In short, if you were, say, a Basic programmer, you could learn to write programs in the style of Basic using C++ syntax, but you couldn’t learn what C++ is actually good (and bad) for. So what’s the point? Alan Perlis once said: “A language that doesn’t affect the way you think about programming, is not worth knowing”. One possible point is that you have to learn a tiny bit of C++ (or more likely, something like JavaScript or Processing) because you need to interface with an existing tool to accomplish a specific task. But then you’re not learning how to program; you’re learning to accomplish that task.C++: (如果你有一定的编程基础)，在24小时之内，能学会一些C++的语法，但是，仅此而已了。如果你以前是个Basic语言的程序员，你可以写一些语法是C++，但是风格是Basic的程序，但是，24小时之内，C++语言的精华或糟粕，你都学不到。重点是什么？(首界图灵奖得主)Alan Perlis曾说过：“不能影响你编程思维方式的语言，是不值得学习的。”一个更加可能的场景是，在工作中，你不得不学习C++（或者JavaScript，Processing之类）的一小部分，来调用一些原有的接口，完成某个特定的任务。这种情况下，表面上说是在学习如何编程，其实只是在应付一下手上的活。in 24 Hours: Unfortunately, this is not enough, as the next section shows.24小时内:很不幸，24小时太少了，原因下面告诉你。 Teach Yourself Programming in Ten Years十年学会编程Researchers (Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)) have shown it takes about ten years to develop expertise in any of a wide variety of areas, including chess playing, music composition, telegraph operation, painting, piano playing, swimming, tennis, and research in neuropsychology and topology. The key is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again. There appear to be no real shortcuts: even Mozart, who was a musical prodigy at age 4, took 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the scene with a string of #1 hits and an appearance on the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critical success, Sgt. Peppers, was released in 1967. 研究表明，想在任何领域成为专家，大概需要10年的时间，这些领域包括下棋，作曲，发电报，弹钢琴，游泳，打网球，研究神经心理学和拓扑学。关键在于有针对性的训练，而不是漫无目的重复，训练的内容要刚好超过你现有的水平，练习以后要分析你的表现，改正发现的错误，然后重复，再重复。没有什么捷径可走，即使是Mozart，一个4岁就能弹琴的音乐天才，也是用了13年的时间，才真正的写出世界级的音乐作品。在流行音乐上，Beatles好像是在1964年访美期间一夜成名的。实际上，他们从1957年就已经开始在利物浦和汉堡的小酒馆里唱歌了，他们组建乐队的时间就更早了，他们第一张取得巨大成功的专辑《佩帕军士》，是在1967年发行的。 Malcolm Gladwell has popularized the idea, although he concentrates on 10,000 hours, not 10 years. Henri Cartier-Bresson (1908-2004) had another metric: “Your first 10,000 photographs are your worst.” (He didn’t anticipate that with digital cameras, some people can reach that mark in a week.) True expertise may take a lifetime: Samuel Johnson (1709-1784) said “Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price.” And Chaucer (1340-1400) complained “the lyf so short, the craft so long to lerne.” Hippocrates (c. 400BC) is known for the excerpt “ars longa, vita brevis”, which is part of the longer quotation “Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”, which in English renders as “Life is short, [the] craft long, opportunity fleeting, experiment treacherous, judgment difficult.” Of course, no single number can be the final answer: it doesn’t seem reasonable to assume that all skills (e.g., programming, chess playing, checkers playing, and music playing) could all require exactly the same amount of time to master, nor that all people will take exactly the same amount of time. As Prof. K. Anders Ericsson puts it, “In most domains it’s remarkable how much time even the most talented individuals need in order to reach the highest levels of performance. The 10,000 hour number just gives you a sense that we’re talking years of 10 to 20 hours a week which those who some people would argue are the most innately talented individuals still need to get to the highest level.” 马尔科姆·格拉德威尔让这个理论广为人知，虽然他说的是另一个说法，10，000个小时而不是10年(这本书有中文翻译版异类 : 不一样的成功启示录)。法国现实主义摄影大师亨利·卡蒂埃-布列松有另外一个标准，他说你的前10,000张照片是你最差的。(当然，这个摄影大师没有意识到数码相机的出现，很多人能在一周内就可以拍10,000张照片)真正的大师要用一生来完成，英国作家，文学评论家和诗人塞缪尔·约翰逊说过：“在任何领域取得卓越的成就都要用一生的努力，不要妄想可以投机取巧。”英国的诗人乔叟也曾经说过：”吾生也有涯 而知也无涯。”同样，公元前400年的希波克拉底也表达过类似的意思，他也认为艺术没有止境，生命却有尽头。他说的这句话有个更长的版本，翻译成英语的意思是：“生命有尽头，艺术无止境，机遇转瞬即逝，练功走火入魔，决定优柔寡断。”当然，不会有一个确定的答案告诉你需要多长时间，毕竟，假设掌握所有的技能(比如编程，下棋，跳棋和音乐)需要相同的时间也不合适，不同的人也会用不同的时间。K.Anders Ericsson教授说过：“值得注意的是，在大多数领域，即使你是个天才，要达到专家级别的高水平仍然需要时间。10，000个小时只是给你一个概念，一个天才，如果每周练习10到20个小时的时间，仍然需要数年时间才能达到专家级别的水平。” So You Want to be a Programmer所以你想成为一个程序员Here’s my recipe for programming success: 这是我编程成功的秘笈: Get interested in programming, and do some because it is fun. Make sure that it keeps being enough fun so that you will be willing to put in your ten years/10,000 hours. 要对编程感兴趣，要从中能获得快乐。保证编程足够有趣，这样才能让你花10年的时间或者10，000个小时在上面也不觉得枯燥无味。 Program. The best kind of learning is learning by doing. To put it more technically, “the maximal level of performance for individuals in a given domain is not attained automatically as a function of extended experience, but the level of performance can be increased even by highly experienced individuals as a result of deliberate efforts to improve.” (p. 366) and “the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors.” (p. 20-21) The book Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life is an interesting reference for this viewpoint. 动手编程。最好的学习方法是边学边做。常言道：“人的最高功力并不能通过做一天和尚撞一天钟这样的重复经验获得，但是，最高的功力可以通过有针对性的日复一日年复一年的训练来获得。”并且，“最有效果的学习需要有针对性的任务，这些任务的难度还要因人而异，并且有合理的反馈渠道，并能够根据这些反馈作出相应的改进。”这些观点引用自《Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life》这本书里。 Talk with other programmers; read other programs. This is more important than any book or training course. 和其他的程序员交流；阅读别人的代码。这比看书或者参加培训课程要重要。 If you want, put in four years at a college (or more at a graduate school). This will give you access to some jobs that require credentials, and it will give you a deeper understanding of the field, but if you don’t enjoy school, you can (with some dedication) get similar experience on your own or on the job. In any case, book learning alone won’t be enough. “Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter” says Eric Raymond, author of The New Hacker’s Dictionary. One of the best programmers I ever hired had only a High School degree; he’s produced a lot of greatsoftware, has his own news group, and made enough in stock options to buy his own nightclub. 如果你愿意，在大学里花上四年时间（或者再读个研）。这能让你获得一些工作机会，也能让你在这个领域有更深入的了解。但是，如果你一上学就头痛，直接去工作也能获得相同的经验。无论是什么情况，读死书肯定是不行的。计算机科学不会让你成为编程专家，就像学习画笔和颜料不可能让你成为画家一样。这是Eric Raymond说的，他是New Hacker’s Dictionary字典的作者。我雇佣过的最好的程序员是个高中毕业的学生，他创造了伟大的软件，Mozilla，他拥有自己的新闻组，赚到了足够多的钱买了自己的酒吧。 Work on projects with other programmers. Be the best programmer on some projects; be the worst on some others. When you’re the best, you get to test your abilities to lead a project, and to inspire others with your vision. When you’re the worst, you learn what the masters do, and you learn what they don’t like to do (because they make you do it for them). 和其他的程序员一起参与一些项目。在一些项目中成为最出色的程序员；在另一些项目中当最差劲的程序员。在当最出色的程序员的时候，要测试你领导项目的能力，用你的视野来启发别人。如果你是项目中最差的那个，要学习牛人们在做什么，如果他们不喜欢做的，你要拿来做。 Work on projects after other programmers. Understand a program written by someone else. See what it takes to understand and fix it when the original programmers are not around. Think about how to design your programs to make it easier for those who will maintain them after you. 接手并推进别人的项目。理解其他人写的代码。如果别人有没有考虑到的问题，你能理解并修复这些问题。思考并设计你的软件，让这些软件容易被他人维护。 Learn at least a half dozen programming languages. Include one language that emphasizes class abstractions (like Java or C++), one that emphasizes functional abstraction (like Lisp or ML or Haskell), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), and one that emphasizes parallelism (like Clojure or Go). 学习至少6种(我不太清楚英语中的half dozen是什么意思，是虚指还是就是6种)编程语言。这6种语言中，包括一种支持抽象类的(例如Java或者C++)，一种支持函数的(Lisp, ML或者Haskell)，一种支持语义抽象的(Lisp)，一种支持声明规范的(Prolog或者C++模板)，还有一种支持并发的(Clojure或Go)。 Remember that there is a “computer“ in “computer science”. Know how long it takes your computer to execute an instruction, fetch a word from memory (with and without a cache miss), read consecutive words from disk, and seek to a new location on disk. (Answers here.) 记住，在“计算机科学”中在“计算机”这个词语。理解执行一条指令要花多长时间，从内存中取一个字（要考虑缓存有没有命中的情况）要多久，从硬盘中连续读字节要多久，在硬盘中寻址定位要多久？ Get involved in a language standardization effort. It could be the ANSI C++ committee, or it could be deciding if your local coding style will have 2 or 4 space indentation levels. Either way, you learn about what other people like in a language, how deeply they feel so, and perhaps even a little about why they feel so. 参加语言的标准化工作。这可能是有关 ANSI C++ 委员会，也可能是缩进的风格是两格缩进或四格缩进。无论如何，你能从中学到其他人对语言的喜好，也能了解到他们热爱的程度，甚至也许能知道一点他们为什么他们会这样认为？ Have the good sense to get off the language standardization effort as quickly as possible. 知道何时能从标准化语言的工作中脱身，越快越好。 With all that in mind, its questionable how far you can get just by book learning. Before my first child was born, I read all the How To books, and still felt like a clueless novice. 30 Months later, when my second child was due, did I go back to the books for a refresher? No. Instead, I relied on my personal experience, which turned out to be far more useful and reassuring to me than the thousands of pages written by experts. 很难说能从书本中学到多少东西。我第一个小孩出生的时候，我读了所有的“如何做”系列的书，但是，没有什么头绪。30个月以后，当我的第二个孩子出生，我还要重温一下那些书么？当然不用了！我都已经是老司机了，我完全靠我自己的经验，事实也证明我自己的经验要胜过那些专家们写的上千页的书。 Fred Brooks, in his essay No Silver Bullet identified a three-part plan for finding great software designers: 弗雷德·布鲁克斯在他的书《没有银弹》中给出了三条建议： Systematically identify top designers as early as possible. 尽早地系统地识别出顶级设计师 Assign a career mentor to be responsible for the development of the prospect and carefully keep a career file. 每个人给分配一个职业规划的导师 Provide opportunities for growing designers to interact and stimulate each other. 让成长中的设计师有机会互相切磋武艺 This assumes that some people already have the qualities necessary for being a great designer; the job is to properly coax them along. Alan Perlis put it more succinctly: “Everyone can be taught to sculpt: Michelangelo would have had to be taught how not to. So it is with the great programmers”. Perlis is saying that the greats have some internal quality that transcends their training. But where does the quality come from? Is it innate? Or do they develop it through diligence? As Auguste Gusteau (the fictional chef in Ratatouille) puts it, “anyone can cook, but only the fearless can be great.” I think of it more as willingness to devote a large portion of one’s life to deliberative practice. But maybe fearless is a way to summarize that. Or, as Gusteau’s critic, Anton Ego, says: “Not everyone can become a great artist, but a great artist can come from anywhere.” 此处假设有一些人天生有成为伟大设计师的潜质，然后，就是正确的去引导他们。艾伦·佩里斯一针见血地说：”假如每个人都可以学会雕刻，那就得教米开朗基罗哪些事不要去做。对于伟大程序员，也是如此。”Perlis认为，伟大的人有一种内在的特质，这种特质往往比接受训练更重要。但是，这些特质是从哪里来的呢？与生俱来的？还是通过后天勤奋而来的？正如 动画片《料理鼠王》里的幻象大厨Auguste Gusteau说的那样：“谁都能做饭，但只有那些无所畏惧的人才能成为大厨！”我认为“把你生命中的大部分时间花在有针对性的练习上”这种精神，看作一种自愿奉献的精神！但或许“无所畏惧”才是体现这种精神的真谛。或者，就像是《料理鼠王》里那个与 Gusteau 作对的刻薄的美食评论家 Anton Ego 说的那样：“不是任何人都能成为伟大的艺术家，不过，伟大的艺术家可以来自任何地方。” So go ahead and buy that Java/Ruby/Javascript/PHP book; you’ll probably get some use out of it. But you won’t change your life, or your real overall expertise as a programmer in 24 hours or 21 days. How about working hard to continually improve over 24 months? Well, now you’re starting to get somewhere… 所以，尽管买本 Java/Ruby/Javascript/PHP 的书吧。你可能会从中学到点儿有用的东西。但作为一个程序员，在 21 天内或 24 小时内改变你的人生，或者提高你实际的编程水平，这是不可能的。你尝试过连续 24 个月不间断的努力提高自己么？好吧，好吧，你该上路了……]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么学生不喜欢上学]]></title>
    <url>%2F2018%2F12%2F24%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[为什么学生不喜欢上学 用你的梦想和理想引领你的一生，要用感恩真诚助人圆梦的心态引领你的一生，要用执着无惧乐观的态度引领你的一生。如果你做到了这些，因缘会给你一切你所应得的。 不要被信条所惑，盲从信条就是活在别人思考的结果里。不要让别人的意见淹没了你内在的心声。最重要的，拥有跟随内心与直觉的勇气，你的内心与直觉多少已经知道那你真正想要成为什么样的人，任何其他事物都是次要的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李开复自传]]></title>
    <url>%2F2018%2F12%2F24%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[价值不是你拥有多少,而是你留下多少. 用你的梦想和理想引领你的一生，要用感恩真诚助人圆梦的心态引领你的一生，要用执着无惧乐观的态度引领你的一生。如果你做到了这些，因缘会给你一切你所应得的。 不要被信条所惑，盲从信条就是活在别人思考的结果里。不要让别人的意见淹没了你内在的心声。最重要的，拥有跟随内心与直觉的勇气，你的内心与直觉多少已经知道那你真正想要成为什么样的人，任何其他事物都是次要的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>自传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构化思维]]></title>
    <url>%2F2018%2F12%2F24%2F%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[结构化思维麦肯锡的7S、BCG的BCG Matrix，也是一种解决问题的结构 麦肯锡的7S麦肯锡7S模型(Mckinsey 7S Model)，简称7s模型，是麦肯锡顾问公司研究中心设计的企业组织七要素，指出了企业在发展过程中必须全面地考虑各方面的情况，包括结构（structure）、制度（system）、风格（style）、员工（staff）、技能（skill）、战略（strategy）、共同的价值观（shared values）。 结构化思维比你想象得重要一万倍 下图有15个数字，我需要你在3秒钟内看完并记住它们，试试？ 是不是觉得有点费力？ 那么，如果我换一下，让你记下面这15个数字，试试？ 是不是觉得So easy？ 其实这两组数字是一样的，只是第二组数字的结构更加有规律。 为什么你很难记住第一组却能够轻松记住第二组呢？因为它更符合我们大脑的使用习惯。 人类大脑在处理信息的时候，有两个规律：第一，不能一次太多，太多信息会让我们的大脑觉得负荷过大；第二，喜欢有规律的信息。]]></content>
      <categories>
        <category>思维方式</category>
      </categories>
      <tags>
        <tag>结构化思维</tag>
      </tags>
  </entry>
</search>
