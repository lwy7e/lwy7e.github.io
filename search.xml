<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>约瑟夫环问题（猴子选大王）</title>
      <link href="/2019/04/16/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B%EF%BC%89PHP%E7%89%88/"/>
      <url>/2019/04/16/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B%EF%BC%89PHP%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>约瑟夫斯问题问题有时候也被描述成猴子选大王问题，题目如下。（最后会贴上约瑟夫问题的来历）</p><p>一群猴子排成一圈，按1,2,…,n依次编号。</p><p>然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。</p><p>要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。</p><p>用程序模拟该过程，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    function monkeyKing($n, $m)</span><br><span class="line">    &#123;</span><br><span class="line">        $arr = range(1, $n);     //构造一个数组</span><br><span class="line">        $i   = 1;                       //从第一个开始循环</span><br><span class="line"></span><br><span class="line">        while (count($arr) &gt; 1) &#123;          //如果总数大于1</span><br><span class="line"></span><br><span class="line">            if ($i % $m != 0) &#123;</span><br><span class="line">                $arr[] = $arr[$i - 1];    //不被踢出则压入数组尾部</span><br><span class="line">            &#125;</span><br><span class="line">            unset($arr[$i - 1]);          //压入数组然后删除</span><br><span class="line">            $i++;                       //继续循环</span><br><span class="line">        &#125;</span><br><span class="line">        return $arr[$i - 1];             //直到剩下最后一个大王</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $king = monkeyKing(5, 3);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function king($n, $m)</span><br><span class="line">&#123;</span><br><span class="line">    $monkey = range(1, $n);            //模拟建立一个连续数组</span><br><span class="line">    $i      = 0;</span><br><span class="line">    while (count($monkey) &gt; 1) &#123;</span><br><span class="line">        $i    += 1;//开始查数</span><br><span class="line">        $head = array_shift($monkey);   //直接一个一个出列最前面的猴子</span><br><span class="line">        if ($i % $m != 0) &#123;</span><br><span class="line">            array_push($monkey, $head);  //如果没数到m或m的倍数,则把该猴放回尾部去.</span><br><span class="line">        &#125;    //否则就抛弃掉了</span><br><span class="line">    &#125;</span><br><span class="line">    return $monkey[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &apos;剩余&apos;, king(3, 4), &apos;号猴子&apos;;</span><br></pre></td></tr></table></figure><p>下面是模拟的过程，对于不剔除的猴子，不断的加入数组尾部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> $n = 5</span><br><span class="line"> $m = 3</span><br><span class="line"> $arr = [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line"> $i   $arr</span><br><span class="line"> ---+------------------------</span><br><span class="line"> 1    x 2 3 4 5 1</span><br><span class="line"> 2    x x 3 4 5 1 2</span><br><span class="line">&gt;3    x x x 4 5 1 2</span><br><span class="line"> 4    x x x x 5 1 2 4</span><br><span class="line"> 5    x x x x x 1 2 4 5</span><br><span class="line">&gt;6    x x x x x x 2 4 5</span><br><span class="line"> 7    x x x x x x x 4 5 2</span><br><span class="line"> 8    x x x x x x x x 5 2 4</span><br><span class="line">&gt;9    x x x x x x x x x 2 4</span><br><span class="line"> 10   x x x x x x x x x x 4 2</span><br><span class="line"> 11   x x x x x x x x x x x 2 4</span><br><span class="line">&gt;12   x x x x x x x x x x x x 4</span><br></pre></td></tr></table></figure><p>据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，<br>他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP使用redis</title>
      <link href="/2019/04/13/PHP%E4%BD%BF%E7%94%A8redis/"/>
      <url>/2019/04/13/PHP%E4%BD%BF%E7%94%A8redis/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP使用redis"><a href="#PHP使用redis" class="headerlink" title="PHP使用redis"></a>PHP使用redis</h1><h2 id="连接到-redis-服务"><a href="#连接到-redis-服务" class="headerlink" title="连接到 redis 服务"></a>连接到 redis 服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    //连接本地的 Redis 服务</span><br><span class="line">   $redis = new Redis();</span><br><span class="line">   $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379);</span><br><span class="line">   //redis设置的密码</span><br><span class="line">   $redis-&gt;auth(&apos;xinglian272&apos;);</span><br><span class="line">   //链接库  不行就是默认0</span><br><span class="line">   $redis-&gt;select(2);</span><br><span class="line">   echo &quot;Connection to server successfully&quot;;</span><br><span class="line">         //查看服务是否运行</span><br><span class="line">   echo &quot;Server is running: &quot; . $redis-&gt;ping();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h2><h3 id="set-get"><a href="#set-get" class="headerlink" title="set get"></a>set get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   //连接本地的 Redis 服务</span><br><span class="line">   $redis = new Redis();</span><br><span class="line">   $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379);</span><br><span class="line">   //设置 redis 字符串数据</span><br><span class="line">   $redis-&gt;set(&quot;tutorial-name&quot;, &quot;Redis tutorial&quot;);</span><br><span class="line">   // 获取存储的数据并输出</span><br><span class="line">   $redis-&gt;get(&quot;tutorial-name&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h3><p>描述：如果在数据库中不存在该键，设置关键值参数<br>参数：key value<br>返回值：BOOL 成功返回：TRUE;失败返回：FALSE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;); </span><br><span class="line">    $redis-&gt;setnx(&apos;test&apos;,&quot;22222222&quot;); </span><br><span class="line">    echo $redis-&gt;get(&apos;test&apos;);  //结果：1111111111111 </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;setnx(&apos;test&apos;,&quot;22222222&quot;); </span><br><span class="line">    echo $redis-&gt;get(&apos;test&apos;);  //结果：22222222 </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h3 id="incr-累加"><a href="#incr-累加" class="headerlink" title="incr(累加)"></a>incr(累加)</h3><p>描述：数字递增存储键值键.<br>参数：key value：将被添加到键的值<br>返回值：INT the new value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;set(&apos;test&apos;,&quot;123&quot;); </span><br><span class="line">    var_dump($redis-&gt;incr(&quot;test&quot;));  //结果：int(124) </span><br><span class="line">    var_dump($redis-&gt;incr(&quot;test&quot;));  //结果：int(125) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="decr-递减"><a href="#decr-递减" class="headerlink" title="decr(递减)"></a>decr(递减)</h3><p>描述：数字递减存储键值。<br>参数：key value：将被添加到键的值<br>返回值：INT the new value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;set(&apos;test&apos;,&quot;123&quot;); </span><br><span class="line">    var_dump($redis-&gt;decr(&quot;test&quot;));  //结果：int(122) </span><br><span class="line">    var_dump($redis-&gt;decr(&quot;test&quot;));  //结果：int(121) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="getMultiple"><a href="#getMultiple" class="headerlink" title="getMultiple"></a>getMultiple</h3><p>描述：取得所有指定键的值。如果一个或多个键不存在，该数组中该键的值为假<br>参数：其中包含键值的列表数组<br>返回值：返回包含所有键的值的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;set(&apos;test1&apos;,&quot;1&quot;); </span><br><span class="line">    $redis-&gt;set(&apos;test2&apos;,&quot;2&quot;); </span><br><span class="line">    $result = $redis-&gt;getMultiple(array(&apos;test1&apos;,&apos;test2&apos;)); </span><br><span class="line">    print_r($result);   //结果：Array ( [0] =&gt; 1 [1] =&gt; 2 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h2><h3 id="lpush-rpush-lrange"><a href="#lpush-rpush-lrange" class="headerlink" title="lpush rpush lrange"></a>lpush rpush lrange</h3><p>lpush 由列表头部添加字符串值<br>rpush 由列表尾部添加字符串值<br>参数：key,value<br>返回值：成功返回数组长度，失败false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   //连接本地的 Redis 服务</span><br><span class="line">   $redis = new Redis();</span><br><span class="line">   $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379);</span><br><span class="line">   //lpush 由列表头部添加字符串值</span><br><span class="line">   $redis-&gt;lpush(&quot;tutorial-list&quot;, &quot;Redis&quot;);</span><br><span class="line">   $redis-&gt;lpush(&quot;tutorial-list&quot;, &quot;Mongodb&quot;);</span><br><span class="line">   //rpush 由列表尾部添加字符串值</span><br><span class="line">   $redis-&gt;rpush(&quot;tutorial-list&quot;, &quot;Mysql&quot;);</span><br><span class="line">   $redis-&gt;rpush(&quot;tutorial-list&quot;, &quot;Nosql&quot;);</span><br><span class="line"></span><br><span class="line">   // 获取存储的数据并输出</span><br><span class="line">   $arList = $redis-&gt;lrange(&quot;tutorial-list&quot;, 0 ,5);</span><br><span class="line">   print_r($arList);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h3 id="lpop"><a href="#lpop" class="headerlink" title="lpop"></a>lpop</h3><p>描述：返回和移除列表的第一个元素<br>参数：key<br>返回值：成功返回第一个元素的值 ，失败返回false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    $redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;); </span><br><span class="line">    var_dump($redis-&gt;lpop(&quot;test&quot;));  //结果：string(3) &quot;222&quot; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="lsize-llen"><a href="#lsize-llen" class="headerlink" title="lsize llen"></a>lsize llen</h3><p>描述：返回的列表的长度。如果列表不存在或为空，该命令返回0。如果该键不是列表，该命令返回FALSE。<br>参数：Key<br>返回值：成功返回数组长度，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    $redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;); </span><br><span class="line">    var_dump($redis-&gt;lsize(&quot;test&quot;));  //结果：int(4) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="lget"><a href="#lget" class="headerlink" title="lget"></a>lget</h3><p>描述：返回指定键存储在列表中指定的元素。 0第一个元素，1第二个… -1最后一个元素，-2的倒数第二…错误的索引或键不指向列表则返回FALSE。<br>参数：key index<br>返回值：成功返回指定元素的值，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    $redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;); </span><br><span class="line">    var_dump($redis-&gt;lget(&quot;test&quot;,3));  //结果：string(3) &quot;444&quot; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="lset"><a href="#lset" class="headerlink" title="lset"></a>lset</h3><p>描述：为列表指定的索引赋新的值,若不存在该索引返回false.<br>参数：key index value<br>返回值：成功返回true,失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    var_dump($redis-&gt;lget(&quot;test&quot;,1));  //结果：string(3) &quot;111&quot; </span><br><span class="line">    var_dump($redis-&gt;lset(&quot;test&quot;,1,&quot;333&quot;));  //结果：bool(true) </span><br><span class="line">    var_dump($redis-&gt;lget(&quot;test&quot;,1));  //结果：string(3) &quot;333&quot; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="lgetrange"><a href="#lgetrange" class="headerlink" title="lgetrange"></a>lgetrange</h3><p>描述：返回在该区域中的指定键列表中开始到结束存储的指定元素，lGetRange(key, start, end)。0第一个元素，1第二个元素… -1最后一个元素，-2的倒数第二…<br>参数：key start end<br>返回值：成功返回查找的值，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    print_r($redis-&gt;lgetrange(&quot;test&quot;,0,-1));  //结果：Array ( [0] =&gt; 222 [1] =&gt; 111 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="lremove"><a href="#lremove" class="headerlink" title="lremove"></a>lremove</h3><p>描述：从列表中从头部开始移除count个匹配的值。如果count为零，所有匹配的元素都被删除。如果count是负数，内容从尾部开始删除。<br>参数：key count value<br>返回值：成功返回删除的个数，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;lpush(&apos;test&apos;,&apos;a&apos;); </span><br><span class="line">    $redis-&gt;lpush(&apos;test&apos;,&apos;b&apos;); </span><br><span class="line">    $redis-&gt;lpush(&apos;test&apos;,&apos;c&apos;); </span><br><span class="line">    $redis-&gt;rpush(&apos;test&apos;,&apos;a&apos;); </span><br><span class="line">    print_r($redis-&gt;lgetrange(&apos;test&apos;, 0, -1)); //结果：Array ( [0] =&gt; c [1] =&gt; b [2] =&gt; a [3] =&gt; a ) </span><br><span class="line">    var_dump($redis-&gt;lremove(&apos;test&apos;,&apos;a&apos;,2));   //结果：int(2) </span><br><span class="line">    print_r($redis-&gt;lgetrange(&apos;test&apos;, 0, -1)); //结果：Array ( [0] =&gt; c [1] =&gt; b ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="List-集合"><a href="#List-集合" class="headerlink" title="List(集合)"></a>List(集合)</h2><h3 id="sadd"><a href="#sadd" class="headerlink" title="sadd"></a>sadd</h3><p>描述：为一个Key添加一个值。如果这个值已经在这个Key中，则返回FALSE。<br>参数：key value<br>返回值：成功返回true,失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    var_dump($redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;));   //结果：bool(true) </span><br><span class="line">    var_dump($redis-&gt;sadd(&apos;test&apos;,&apos;333&apos;));   //结果：bool(true) </span><br><span class="line">    print_r($redis-&gt;sort(&apos;test&apos;)); //结果：Array ( [0] =&gt; 111 [1] =&gt; 333 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="sremove"><a href="#sremove" class="headerlink" title="sremove"></a>sremove</h3><p>描述：删除Key中指定的value值<br>参数：key member<br>返回值：true or false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test&apos;,&apos;333&apos;); </span><br><span class="line">    $redis-&gt;sremove(&apos;test&apos;,&apos;111&apos;); </span><br><span class="line">    print_r($redis-&gt;sort(&apos;test&apos;));    //结果：Array ( [0] =&gt; 333 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="smove"><a href="#smove" class="headerlink" title="smove"></a>smove</h3><p>描述：将Key1中的value移动到Key2中<br>参数：srcKey dstKey member<br>返回值：true or false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;delete(&apos;test1&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test&apos;,&apos;333&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test1&apos;,&apos;222&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test1&apos;,&apos;444&apos;); </span><br><span class="line">    $redis-&gt;smove(&apos;test&apos;,&quot;test1&quot;,&apos;111&apos;); </span><br><span class="line">    print_r($redis-&gt;sort(&apos;test1&apos;));    //结果：Array ( [0] =&gt; 111 [1] =&gt; 222 [2] =&gt; 444 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="scontains"><a href="#scontains" class="headerlink" title="scontains"></a>scontains</h3><p>描述：检查集合中是否存在指定的值。<br>参数：key value<br>返回值：true or false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test&apos;,&apos;112&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test&apos;,&apos;113&apos;); </span><br><span class="line">    var_dump($redis-&gt;scontains(&apos;test&apos;, &apos;111&apos;)); //结果：bool(true) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="ssize"><a href="#ssize" class="headerlink" title="ssize"></a>ssize</h3><p>描述：返回集合中存储值的数量<br>参数：key<br>返回值：成功返回数组个数，失败0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); </span><br><span class="line">    $redis-&gt;sadd(&apos;test&apos;,&apos;112&apos;); </span><br><span class="line">    echo $redis-&gt;ssize(&apos;test&apos;);   //结果：2 </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="spop"><a href="#spop" class="headerlink" title="spop"></a>spop</h3><p>描述：随机移除并返回key中的一个值<br>参数：key<br>返回值：成功返回删除的值，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    var_dump($redis-&gt;spop(&quot;test&quot;));  //结果：string(3) &quot;333&quot; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="sinter"><a href="#sinter" class="headerlink" title="sinter"></a>sinter</h3><p>描述：返回一个所有指定键的交集。如果只指定一个键，那么这个命令生成这个集合的成员。如果不存在某个键，则返回FALSE。<br>参数：key1, key2, keyN<br>返回值：成功返回数组交集，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); </span><br><span class="line">    var_dump($redis-&gt;sinter(&quot;test&quot;,&quot;test1&quot;));  //结果：array(1) &#123; [0]=&gt; string(3) &quot;111&quot; &#125; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="sinterstore"><a href="#sinterstore" class="headerlink" title="sinterstore"></a>sinterstore</h3><p>描述：执行sInter命令并把结果储存到新建的变量中。<br>参数：<br>Key: dstkey, the key to store the diff into.<br>Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.<br>返回值：成功返回，交集的个数，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); </span><br><span class="line">    var_dump($redis-&gt;sinterstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;));  //结果：int(1) </span><br><span class="line">    var_dump($redis-&gt;smembers(&apos;new&apos;));  //结果:array(1) &#123; [0]=&gt; string(3) &quot;111&quot; &#125; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="sunion"><a href="#sunion" class="headerlink" title="sunion"></a>sunion</h3><p>描述：返回一个所有指定键的并集<br>参数：<br>Keys: key1, key2, … , keyN<br>返回值：成功返回合并后的集，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); </span><br><span class="line">    print_r($redis-&gt;sunion(&quot;test&quot;,&quot;test1&quot;));  //结果：Array ( [0] =&gt; 111 [1] =&gt; 222 [2] =&gt; 333 [3] =&gt; 444 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="sunionstore"><a href="#sunionstore" class="headerlink" title="sunionstore"></a>sunionstore</h3><p>描述：执行sunion命令并把结果储存到新建的变量中。<br>参数：<br>Key: dstkey, the key to store the diff into.<br>Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.<br>返回值：成功返回，交集的个数，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); </span><br><span class="line">    var_dump($redis-&gt;sinterstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;));  //结果：int(4) </span><br><span class="line">    print_r($redis-&gt;smembers(&apos;new&apos;));  //结果:Array ( [0] =&gt; 111 [1] =&gt; 222 [2] =&gt; 333 [3] =&gt; 444 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="sdiff"><a href="#sdiff" class="headerlink" title="sdiff"></a>sdiff</h3><p>描述：返回第一个集合中存在并在其他所有集合中不存在的结果<br>参数：Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis.<br>返回值：成功返回数组，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); </span><br><span class="line">    print_r($redis-&gt;sdiff(&quot;test&quot;,&quot;test1&quot;));  //结果：Array ( [0] =&gt; 222 [1] =&gt; 333 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="sdiffstore"><a href="#sdiffstore" class="headerlink" title="sdiffstore"></a>sdiffstore</h3><p>描述：执行sdiff命令并把结果储存到新建的变量中。<br>参数：<br>Key: dstkey, the key to store the diff into.<br>Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis<br>返回值：成功返回数字，失败false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); </span><br><span class="line">    var_dump($redis-&gt;sdiffstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;));  //结果：int(2) </span><br><span class="line">    print_r($redis-&gt;smembers(&apos;new&apos;));  //结果:Array ( [0] =&gt; 222 [1] =&gt; 333 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="smembers-sgetmembers"><a href="#smembers-sgetmembers" class="headerlink" title="smembers, sgetmembers"></a>smembers, sgetmembers</h3><p>描述：<br>返回集合的内容<br>参数：Key: key<br>返回值：An array of elements, the contents of the set.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); </span><br><span class="line">    $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); </span><br><span class="line">    print_r($redis-&gt;smembers(&apos;test&apos;));  //结果:Array ( [0] =&gt; 111 [1] =&gt; 222 ) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete(删除)"></a>delete(删除)</h2><p>参数：一个键，或不确定数目的参数，每一个关键的数组：key1 key2 key3 … keyN<br>返回值：删除的项数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $redis = new redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    $redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;); </span><br><span class="line">    echo $redis-&gt;get(&apos;test&apos;);   //结果：1111111111111 </span><br><span class="line">    $redis-&gt;delete(&apos;test&apos;); </span><br><span class="line">    var_dump($redis-&gt;get(&apos;test&apos;));  //结果：bool(false) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h2 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h2><p>参数key<br>返回值：Bool 成功返回：TRUE;失败返回：FALSE<br>描述：验证指定的键是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$redis = new redis(); </span><br><span class="line">$redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">$redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;); </span><br><span class="line">var_dump($redis-&gt;exists(&apos;test&apos;));  //结果：bool(true) </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门</title>
      <link href="/2019/03/27/docker%E5%85%A5%E9%97%A8/"/>
      <url>/2019/03/27/docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>Mac：<a href="https://docs.docker.com/docke.." target="_blank" rel="noopener">https://docs.docker.com/docke..</a>.<br>Windows:<a href="https://docs.docker.com/docke.." target="_blank" rel="noopener">https://docs.docker.com/docke..</a>.<br>linux:官网有不同版本的安装的教程<br>ubuntu:<a href="https://docs.docker.com/engin.." target="_blank" rel="noopener">https://docs.docker.com/engin..</a>.</p><h1 id="Docker三个基本概念"><a href="#Docker三个基本概念" class="headerlink" title="Docker三个基本概念"></a>Docker三个基本概念</h1><p>下面这张图非常的经典，很形象地展示了，什么是容器，什么是镜像，什么是仓库，以及三者之间的联系。</p><p><img src="/2019/03/27/docker入门/d.png" alt="docker"></p><p>接下来我们来解释一下这张图。现在我们要造一间厨房，在造之前我们首先要干的一件事，就是先列举出我们造厨房需要的东西。我们可能需要一个通了水电煤的房子以及一些必需的厨房用具诸如锅碗瓢勺、煤气灶、冰箱、水槽等等这些东西。现在我们知道需要了什么东西之后，我们就去找这些东西。首先我们先去京东购买一些厨房用具，这些用具就好比我们的Docker镜像，我们厨房的用具到了之后得找个地方把它们放在，不可能随处丢吧，不然后面用的时候就找不到它了，那么我们Docker镜像也是这样，需要一个Docker仓库去存储这些镜像。现在我们有了这些厨房用具之后就可以做饭了吗？答案当然是不能，没水没电没火啊！这时候我们得把厨房用具给装到一个通了水电煤的房子才行，那么Docker镜像也是这样，单纯的Docker镜像是不能用的，它得装到Docker容器中通了水电煤才能使用。等我们装好了厨房用具之后我们就可以开始做饭，那么我们的Docker镜像装到Docker容器之后，我们应用就可以跑起来了。</p><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><p>1.杀死所有正在运行的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill $(docker ps -a -q)</span><br></pre></td></tr></table></figure></p><p>2.删除所有已经停止的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure></p><p>3.删除所有镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure></p><p>4.关闭容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop CONTAINER ID或者NAMES</span><br></pre></td></tr></table></figure></p><p>5.重新启动关闭的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start CONTAINER ID或者NAMES</span><br></pre></td></tr></table></figure></p><p>6.移除本地容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm CONTAINER ID或者NAMES</span><br></pre></td></tr></table></figure></p><p>7.查看本地容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps  //查看正在运行的容器</span><br><span class="line">docker ps -a //查看所有容器</span><br></pre></td></tr></table></figure></p><p>8.查看本地镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></p><p>9.创建镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t name:tag Dockerfile路径</span><br></pre></td></tr></table></figure></p><p>10.修改本地镜像标记<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag  IMAGE ID  name:tag </span><br><span class="line">docker rmi name:tag</span><br></pre></td></tr></table></figure></p><p>11.删除本地镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi name:tag或者IMAGE ID</span><br></pre></td></tr></table></figure></p><p>12.进入容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it IMAGE ID或者NAMES /bin/bash</span><br></pre></td></tr></table></figure></p><p>13.获取镜像中心的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull name:tag</span><br></pre></td></tr></table></figure></p><p>14.获取容器的端口映射配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port CONTAINER ID或者NAMES</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows上利用docker搭建lnmp开发环境</title>
      <link href="/2019/03/27/windows%E4%B8%8A%E5%88%A9%E7%94%A8docker%E6%90%AD%E5%BB%BAlnmp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/03/27/windows%E4%B8%8A%E5%88%A9%E7%94%A8docker%E6%90%AD%E5%BB%BAlnmp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>到<a href="https://www.docker.com/" target="_blank" rel="noopener">docker官网</a>进行安装<br>书籍:Docker技术入门与实战 </p><h1 id="开启Hyper-V"><a href="#开启Hyper-V" class="headerlink" title="开启Hyper-V"></a>开启Hyper-V</h1><p>打开控制面板 - 程序和功能 - 启用或关闭Windows功能，勾选Hyper-V，然后点击确定即可，如图：<br><img src="/2019/03/27/windows上利用docker搭建lnmp开发环境/v.png" alt="Hyper-V"></p><p>下载windwos版本docker安装包 地址</p><h1 id="修改docker-镜像仓库"><a href="#修改docker-镜像仓库" class="headerlink" title="修改docker 镜像仓库"></a>修改docker 镜像仓库</h1><p>安装好后登陆docker（没有账号的请到官网进行注册）<br><img src="/2019/03/27/windows上利用docker搭建lnmp开发环境/v2.png" alt="Hyper-V"></p><h1 id="使用git快速获取lnmp"><a href="#使用git快速获取lnmp" class="headerlink" title="使用git快速获取lnmp"></a>使用git快速获取lnmp</h1><p>切换到你准备安装dnmp的目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/shmilylbelva/dnmp.git</span><br><span class="line">$ cd dnmp</span><br><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure><p>完成以后可以在浏览器中访问localhost，出现界面代表ok</p><h1 id="站点部署"><a href="#站点部署" class="headerlink" title="站点部署"></a>站点部署</h1><p><code>c:\Windows\System32\Drivers\etc\hosts</code></p><p>本文有默认加了两个站点：<a href="http://www.site1.com（同localhost）和www.site2.com。" target="_blank" rel="noopener">www.site1.com（同localhost）和www.site2.com。</a><br>要在本地访问这两个域名，需要修改你的hosts文件，添加以下两行：<br>127.0.0.1 <a href="http://www.site1.com" target="_blank" rel="noopener">www.site1.com</a><br>127.0.0.1 <a href="http://www.site2.com" target="_blank" rel="noopener">www.site2.com</a><br>其中，<a href="http://www.site2.com为支持SSL/https和HTTP/2的示例站点。" target="_blank" rel="noopener">www.site2.com为支持SSL/https和HTTP/2的示例站点。</a><br>因为站点2的SSL采用自签名方式，所以浏览器有安全提示，继续访问就可以了，自己的站点用第三方SSL认证证书替换即可。<br>如果只用到站点1，把站点2相关的目录和配置文件删除：<br>./conf/nginx/conf.d/certs/site2/<br>./conf/nginx/conf.d/site2.conf<br>./www/site2/<br>重启容器内的Nginx生效：<br>docker exec -it dlnmp_nginx nginx -s reload</p><h1 id="dnmp目录结构"><a href="#dnmp目录结构" class="headerlink" title="dnmp目录结构"></a>dnmp目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── conf                        配置目录</span><br><span class="line">│   ├── conf.d              站点配置文件目录</span><br><span class="line">│   │   ├── certs           SSL认证文件、密钥和加密文件目录</span><br><span class="line">│   │   │   └── site2       站点2的认证文件目录</span><br><span class="line">│   │   ├── site1.conf      站点1 Nginx配置文件</span><br><span class="line">│   │   └── site2.conf      站点2 Nginx配置文件 </span><br><span class="line">│   ├── my.cnf              MySQL配置文件           </span><br><span class="line">│   ├── nginx.conf          Nginx通用配置文件</span><br><span class="line">│   ├── php-fpm.d           PHP-FPM配置目录</span><br><span class="line">│   │   └── www.conf        PHP-FPM配置文件</span><br><span class="line">│   ├── php.ini             PHP配置文件</span><br><span class="line">├── docker-compose.yml        默认容器启动配置文件</span><br><span class="line">├── docker-compose54.yml      php5.4容器启动配置文件</span><br><span class="line">├── docker-compose56.yml      php5.6容器启动配置文件</span><br><span class="line">├── log                         日志目录</span><br><span class="line">│   ├── mysql.slow.log                   MySQL日志</span><br><span class="line">│   ├── nginx.error.log                   Nginx日志</span><br><span class="line">│   ├── nginx.site1.error.log          </span><br><span class="line">│   ├── nginx.site2.error.log           </span><br><span class="line">├── mysql                       MySQL数据文件目录</span><br><span class="line">├── php                          PHP版本目录</span><br><span class="line">└── www                         站点根目录</span><br><span class="line">    ├── site1                   站点1根目录</span><br><span class="line">    └── site2                   站点2根目录</span><br></pre></td></tr></table></figure><h1 id="MYSQL说明"><a href="#MYSQL说明" class="headerlink" title="MYSQL说明"></a>MYSQL说明</h1><p>在docker-compose.yml文件中，我们指定了MySQL数据库root用户的密码为123456。<br>所以，我们就可以在主机中通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -h 127.0.0.1 -u root -p  #linux中</span><br><span class="line">#在mac中需要先切换到mysql容器</span><br><span class="line">$ docker container ls  #列出容器列表</span><br><span class="line">$ docker exec -it 775c7c9ee1e1 /bin/bash  #其中的容器id不用输入完整的mysql容器id,一般3位就能区分。</span><br><span class="line">$ mysql -h 127.0.0.1 -uroot -p</span><br></pre></td></tr></table></figure><p>输入密码，就可以进入MySQL命令行。</p><p>说明：这里MySQL的连接主机不能用localhost，因为MySQL客户端默认使用unix socket方式连接，应该直接用本地IP。<br>在PHP代码中的使用方式与在主机中使用稍有不同，如下：<br>$pdo = new PDO(‘mysql:host=mysql;dbname=site1’, ‘root’, ‘123456’);<br>其中，host的值就是在docker-compose.yml里面指定的MySQL容器的名称。<br>这是因为PHP代码是在FPM容器中，FPM容器启动时会自动在/etc/hosts中加上：<br>172.17.0.2 mysql 11e55f91c4c3 dnmp_mysql<br>就是说，mysql自动指向了MySQL容器动态生成的IP。<br>注意，这里用php进行mysql连接测试会失败（在docker-compose up的时候注意到存在mbind:Operation not permitted 这个提示）</p><p>，所以还需要处理上述问题。<br>进入刚刚的mysql终端,内容大致如下。host为 % 表示不限制ip localhost表示本机使用 plugin非mysql_native_password 则需要修改密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select host,user,plugin,authentication_string from mysql.user;    </span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+  </span><br><span class="line">| host      | user             | plugin                | authentication_string                                                  |  </span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+  </span><br><span class="line">| %         | root             | caching_sha2_password | $A$005$^]RQB&#125;j~t!      .#v)3.UogPRFu8VJA5/GKEbK5edEQlMT5sHw2n72zYJNlIbo3 |  </span><br><span class="line">| localhost | mysql.infoschema | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              |  </span><br><span class="line">| localhost | mysql.session    | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              |  </span><br><span class="line">| localhost | mysql.sys        | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              |  </span><br><span class="line">| localhost | root             | caching_sha2_password | $A$005$Y6&amp;q!59^Fmh)@-6TG58J3F5+3I/HI9L|JCadNG+-+d6W+1D_UFW+7MRD7F3 |  </span><br><span class="line">+-----------+------------------+-----------------------+------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>依次进行如下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#更新一下用户的密码 root用户密码为newpassword  </span><br><span class="line">mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>mysql连接问题解决。</p><h1 id="修改docker-compose-yml"><a href="#修改docker-compose-yml" class="headerlink" title="修改docker-compose.yml"></a>修改docker-compose.yml</h1><p>如果容器已经生成，回头再编辑docker-compose.yml，用<br>docker-compose up<br>命令会直接启动原来的容器，修改的内容不会体现在启动的容器里。<br>所以，要使修改的docker-compose.yml生效，需要以下4步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop dnmp_nginx                      # 第一步：停止容器</span><br><span class="line">$ docker rm dnmp_nginx                        # 第二步：删除容器</span><br><span class="line"># !!第三步：重启Docker服务!!</span><br><span class="line">$ docker-compose up -d --no-deps --build mysql  # 第四步：重新启动容器</span><br></pre></td></tr></table></figure><p>其中最后一条命令参数作用：/<br>-d：后台执行<br>–no-deps：不启动link的容器<br>–build：启动容器前先构建镜像</p><h1 id="使用Redis"><a href="#使用Redis" class="headerlink" title="使用Redis"></a>使用Redis</h1><p>Redis使用和MySQL类似。<br>不过需要注意的是在./php/php72中的Dockerfile末尾的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#源码安装方式</span><br><span class="line">#php7 can install</span><br><span class="line"></span><br><span class="line">ENV PHPREDIS_VERSION 4.0.0</span><br><span class="line">RUN curl -L -o /tmp/redis.tar.gz https://github.com/phpredis/phpredis/archive/$PHPREDIS_VERSION.tar.gz \</span><br><span class="line">    &amp;&amp; tar xfz /tmp/redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /tmp/redis.tar.gz \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/php/ext \</span><br><span class="line">    &amp;&amp; mv phpredis-$PHPREDIS_VERSION /usr/src/php/ext/redis \</span><br><span class="line">    &amp;&amp; docker-php-ext-install redis \</span><br><span class="line">    &amp;&amp; rm -rf /usr/src/php</span><br></pre></td></tr></table></figure><p>如果是php5.X那么这里应该是这样的（需要自己添加到对应的Dockerfile中，然后再docker-compose up）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#PECL安装方式</span><br><span class="line">#php5 can install</span><br><span class="line"></span><br><span class="line">#添加扩展 redis pecl方式</span><br><span class="line">RUN apk add --no-cache --update libmemcached-libs zlib</span><br><span class="line">RUN set -xe \</span><br><span class="line">    &amp;&amp; apk add --no-cache --update --virtual .phpize-deps $PHPIZE_DEPS \</span><br><span class="line">    &amp;&amp; pecl install -o -f redis  \</span><br><span class="line">    &amp;&amp; echo &quot;extension=redis.so&quot; &gt; /usr/local/etc/php/conf.d/redis.ini</span><br><span class="line">    &amp;&amp; rm -rf /usr/share/php \</span><br><span class="line">    &amp;&amp; rm -rf /tmp/* \</span><br><span class="line">    &amp;&amp; apk del  .phpize-deps</span><br></pre></td></tr></table></figure><p>在主机和容器内部都通过地址127.0.0.1，端口6379访问。</p><p>PHP则是跨容器访问，host参数用redis（links指定的名称），端口用6379。<br>修改site2的index.php文件内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $redis = new Redis();</span><br><span class="line">    $redis-&gt;connect(&apos;192.168.1.11&apos;,6379);//修改成自己的ip</span><br><span class="line">    $redis-&gt;set(&apos;name&apos;,&apos;青波&apos;);</span><br><span class="line">    echo $redis-&gt;get(&apos;name&apos;);</span><br><span class="line">        //检测是否连接成功</span><br></pre></td></tr></table></figure><p>浏览器访问<a href="http://www.site2.com,出现‘青波’即代表redis扩展正常。" target="_blank" rel="noopener">www.site2.com,出现‘青波’即代表redis扩展正常。</a></p><p>作者：回眸淡然笑<br>链接：<a href="https://www.jianshu.com/p/31c09a3e0d5d" target="_blank" rel="noopener">https://www.jianshu.com/p/31c09a3e0d5d</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写文章（基于 Markdown）</title>
      <link href="/2019/03/23/markdown/"/>
      <url>/2019/03/23/markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h1><p>在站点文件夹中打开 git bash，输入如下命令创建文章，其中 title 为文章的标题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"title"</span></span><br></pre></td></tr></table></figure></p><p>当输入命令后，就会在 source/_post 文件夹下创建一个文件，命名为：title.md<br>这个文件就是将要发布到网站上的原始文件，用于记录文章内容<br>下面，我们将要在这个文件中写下我们的第一篇博客</p><h1 id="编写文章（基于-Markdown）"><a href="#编写文章（基于-Markdown）" class="headerlink" title="编写文章（基于 Markdown）"></a>编写文章（基于 Markdown）</h1><h2 id="Markdown-简介"><a href="#Markdown-简介" class="headerlink" title="Markdown 简介"></a>Markdown 简介</h2><p>但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式</span><br></pre></td></tr></table></figure></p><p>基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言</p><h2 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h2><p>在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora<br>按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览<br>这里附上 Typora 的下载地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br><span class="line"><span class="comment">#### 四级标题</span></span><br><span class="line"><span class="comment">##### 五级标题</span></span><br><span class="line"><span class="comment">###### 六级标题</span></span><br></pre></td></tr></table></figure><h3 id="粗体、斜体、删除线和下划线"><a href="#粗体、斜体、删除线和下划线" class="headerlink" title="粗体、斜体、删除线和下划线"></a>粗体、斜体、删除线和下划线</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文字引用</span><br></pre></td></tr></table></figure><h3 id="公式块"><a href="#公式块" class="headerlink" title="公式块"></a>公式块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：---</span><br><span class="line"></span><br><span class="line">方法二：+++</span><br><span class="line"></span><br><span class="line">方法三：***</span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项</span><br><span class="line"></span><br><span class="line">* 无序列表项</span><br><span class="line"></span><br><span class="line">+ 无序列表项</span><br><span class="line"></span><br><span class="line">- 无序列表项</span><br></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头1|表头2</span><br><span class="line">-|-|-</span><br><span class="line">内容11|内容12</span><br><span class="line">内容21|内容22</span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：[链接文字](链接地址 <span class="string">"链接描述"</span>)</span><br><span class="line">例如：[示例链接](https://www.example.com/ <span class="string">"示例链接"</span>)</span><br><span class="line"></span><br><span class="line">方法二：&lt;链接地址&gt;</span><br><span class="line">例如：&lt;https://www.example.com/&gt;</span><br></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片文字](图片地址 <span class="string">"图片描述"</span>)</span><br><span class="line">例如：![示例图片](https://www.example.com/example.PNG <span class="string">"示例图片"</span>)</span><br></pre></td></tr></table></figure><p>说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置<br>将 站点配置文件 中的 post_asset_folder 选项的值设置为 true<br>在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件<br>这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，<br>我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可<br>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，<br>则可以在对应的文章中使用语句 <img src="/2019/03/23/markdown/title/example.PNG" alt="示例图片" title="示例图片"> 添加图片(注意有感叹号!前面)</p><h1 id="Hexo-NexT-内置标签"><a href="#Hexo-NexT-内置标签" class="headerlink" title="Hexo NexT 内置标签"></a>Hexo <a href="http://theme-next.iissnan.com/tag-plugins.html" target="_blank" rel="noopener">NexT 内置标签</a></h1><p>「标签」(Tag Plugin) 是 Hexo 提供的一种快速生成特定内容的方式。<br>例如，在标准 Markdown 语法中，我们无法指定图片的大小。<br>这种情景，我们即可使用标签来解决。 Hexo 内置来许多标签来帮助写作者可以更快的书写，<br>完整的标签列表 可以参考 Hexo 官网。 另外，Hexo 也开放来接口给主题，使主题有可能提供给写作者更简便的写作方法。<br>以下标签便是 NexT 主题当前提供的标签。</p><h2 id="文本居中的引用"><a href="#文本居中的引用" class="headerlink" title="文本居中的引用"></a>文本居中的引用</h2><p>此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。<br>文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。<br>例如作为文章开篇引用 或者 结束语之前的总结引用。</p><p>使用方式</p><ul><li>HTML方式：使用这种方式时，给 img 添加属性 class=”blockquote-center” 即可。</li><li>标签方式：使用 centerquote 或者 简写 cq。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span><br><span class="line">&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;</span><br><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;</span><br><span class="line">&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 标签别名 --&gt;</span><br><span class="line">&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/23/markdown/blockquote-center.png" alt="示例图片" title="示例图片"></p><h2 id="突破容器宽度限制的图片"><a href="#突破容器宽度限制的图片" class="headerlink" title="突破容器宽度限制的图片"></a>突破容器宽度限制的图片</h2><p>当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片,<br>图片的扩大与容器的偏差从视觉上提升图片的吸引力。 此标签有两种调用方式（详细参看底下示例）：</p><p>使用方式</p><ul><li>HTML方式：使用这种方式时，为 img 添加属性 class=”full-image”即可。</li><li>标签方式：使用 fullimage 或者 简写 fi， 并传递图片地址、 alt 和 title 属性即可。 属性之间以逗号分隔。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式。</span><br><span class="line">如果要在图片下显示图片的标题，请使用 标签方式 并给定 title 属性。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span><br><span class="line">&lt;!-- 其中 class=&quot;full-image&quot; 是必须的 --&gt;</span><br><span class="line">&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;</span><br><span class="line">&#123;% fullimage /image-url, alt, title %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 别名 --&gt;</span><br><span class="line">&#123;% fi /image-url, alt, title %&#125;</span><br></pre></td></tr></table></figure><h2 id="Bootstrap-Callout-由-ivan-nginx-贡献"><a href="#Bootstrap-Callout-由-ivan-nginx-贡献" class="headerlink" title="Bootstrap Callout 由 ivan-nginx 贡献"></a>Bootstrap Callout 由 <a href="https://github.com/iissnan/hexo-theme-next/pull/1160" target="_blank" rel="noopener">ivan-nginx</a> 贡献</h2><p>这些样式出现在 <a href="https://getbootstrap.com/" target="_blank" rel="noopener">Bootstrap</a> 的官方文档中。</p><p>使用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p><p>其中，class_name 可以是以下列表中的一个值：</p><ul><li>default</li><li>primary</li><li>success</li><li>info</li><li>warning</li><li>danger</li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言入门笔记</title>
      <link href="/2019/03/23/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/23/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/23/Go语言入门笔记/go.jpg" alt="Go"><br>工作需要入手了 Go 语言，开发使用的是 <a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">Gin Web Framework</a>。</p><p>入手后发现语法和 PHP/Python/JavaScript 之流还是有很大区别的，下面对学习资料及入门笔记做简单整理。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Go（又称 Golang ），由 Google 开发</li><li>是一种 静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言</li><li>语法接近 C 语言，但对于变量的声明有所不同</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装</p><p>直接前往 <a href="https://golang.org/dl/" target="_blank" rel="noopener">官网</a> 下载 .pkg 完成安装。<br><a href="https://studygolang.com/" target="_blank" rel="noopener">go中文网</a> 一般去中文网下载</p><h3 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h3><p>用于放置一个 go 程序员的所有 go 代码和依赖。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li>src：go源码文件</li><li>pkg：package object（编译出的二进制文件）</li><li>bin：可执行文件（编译出的二进制文件）</li></ul><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>workspace 的路径，默认为 $HOME/go。</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>直接安装 .pkg 文件未设置 GOPATH，需要手动设置一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/go</span><br></pre></td></tr></table></figure></p><p>加入环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:$(go env GOPATH)/bin</span><br></pre></td></tr></table></figure><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>折腾了好久别的编辑器还是用<a href="https://www.jetbrains.com/" target="_blank" rel="noopener">jetbrains</a> 的 <a href="https://www.jetbrains.com/go/?fromMenu" target="_blank" rel="noopener">GoLand</a> 舒服<br>功能齐全</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h2><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>程序入口为：main.main。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hello-go"><a href="#hello-go" class="headerlink" title="hello.go"></a>hello.go</h3><p>创建新项目：/Users/jjy/go/src/exampleProject，新建文件 hello.go：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, world!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在 /Users/jjy/go/src/exampleProject 下执行 go install，之后会在 $GOPATH/bin 目录下生成编译后的二进制程序。</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">▶ /Users/jjy/go/bin/exampleProject</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><ul><li>函数多返回值</li><li><a href="https://studygolang.com/articles/13875" target="_blank" rel="noopener">并发编程</a></li><li><a href="http://www.runoob.com/go/go-error-handling.html" target="_blank" rel="noopener">错误处理</a></li></ul><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li><a href="https://go-zh.org/doc/" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://cyent.github.io/golang/method/overview/" target="_blank" rel="noopener">Go语言学习 - cyent笔记</a></li><li><a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">awesome-go</a></li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN" target="_blank" rel="noopener">Go 入门指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序是怎么跑起来的</title>
      <link href="/2019/01/04/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
      <url>/2019/01/04/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h3 id="对程序员来说CPU是什么？"><a href="#对程序员来说CPU是什么？" class="headerlink" title="对程序员来说CPU是什么？"></a>对程序员来说CPU是什么？</h3><h4 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h4><p>1.程序是什么？<br>2.程序是由什么组成的？<br>3.什么是机器语言？<br>4.正在运行的程序存储在什么位置？<br>5.什么是内存地址？<br>6.计算机的构成原件中，负责程序的解释和运行的是哪个？</p><p>我的第一次回答<br>1.计算机运行的命令<br>2.由指令和数据组成<br>3.计算机可以直接识别的语言<br>4.内存<br>5.一个位置<br>6.CPU</p><p>答案</p><p>1.指示计算机每一步动作的一组指令<br>2.指令和数据<br>3.CPU可以直接识别并使用的语言<br>4.内存<br>5.内存中，用来表示命令和数据存储位置的数值<br>6.CPU</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十年学会编程</title>
      <link href="/2019/01/02/%E5%8D%81%E5%B9%B4%E5%AD%A6%E4%BC%9A%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/01/02/%E5%8D%81%E5%B9%B4%E5%AD%A6%E4%BC%9A%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>十年学会编程</p><h3 id="Teach-Yourself-Programming-in-Ten-Years"><a href="#Teach-Yourself-Programming-in-Ten-Years" class="headerlink" title="Teach Yourself Programming in Ten Years"></a>Teach Yourself Programming in Ten Years</h3><h4 id="Peter-NorviG"><a href="#Peter-NorviG" class="headerlink" title="Peter NorviG"></a>Peter NorviG</h4><h3 id="Why-is-everyone-in-such-a-rush？"><a href="#Why-is-everyone-in-such-a-rush？" class="headerlink" title="Why is everyone in such a rush？"></a>Why is everyone in such a rush？</h3><p>为何每个人都急于求成?<br>Walk into any bookstore, and you’ll see how to Teach Yourself Java in 24 Hours alongside endless variations offering to teach C, SQL, Ruby, Algorithms, and so on in a few days or hours. The Amazon advanced search for [title: teach, yourself, hours, since: 2000 and found 512 such books. Of the top ten, nine are programming books (the other is about bookkeeping). Similar results come from replacing “teach yourself” with “learn” or “hours” with “days.”</p><p>随便走进一家书店，都会看到类似《24小时学会Java》这样的书，旁边摆着的是大量诸如在几天，几小时之内学会C语言，SQL，Ruby以及算法这样的书。如果使用Amazon上的高级搜索，使用title: teach, yourself, hours, since: 2000这个关键字来搜索，将会返回512本书。最靠前的10本书中，有9本是编程的书（唯一的例外是一本记账的书）。如果把关键字”teach yourself”替换成”learn”，或者将”hours”替换成”days”，返回的结果大同小异。</p><p>The conclusion is that either people are in a big rush to learn about programming, or that programming is somehow fabulously easier to learn than anything else. Felleisen et al. give a nod to this trend in their book How to Design Programs, when they say “Bad programming is easy. Idiots can learn it in 21 days, even if they are dummies.” The Abtruse Goose comic also had their take.</p><p>很明显，人们在学习编程的时候喜欢大跃进，或者认为编程比起其它事情来，是小菜一碟的事。Felleisen在他的书《How to Design Program》里说：“编烂程一点也不难。傻瓜也可以在21天内学会，即使他们是傻逼。”在搞笑漫画网站Abtruse Goose也在这个漫画中表达了同样的看法。</p><p>Let’s analyze what a title like Teach Yourself C++ in 24 Hours could mean:</p><p>我们来看看类似《24小时自学C++》这种标题党，到底说的什么鬼东西：</p><p><strong>Teach Yourself</strong>: In 24 hours you won’t have time to write several significant programs, and learn from your successes and failures with them. You won’t have time to work with an experienced programmer and understand what it is like to live in a C++ environment. In short, you won’t have time to learn much. So the book can only be talking about a superficial familiarity, not a deep understanding. As Alexander Pope said, a little learning is a dangerous thing.<br><strong>自学</strong>: 24小时之内，你没有时间写几个有意义的程序，也就无法从成功或失败中学到经验。24小时之内，你没有时间和一个有经验的程序员合作交流，也就无从理解使用C++编程的真实场景。简单来说，时间太短，你啥也学不到。因此，有这种干货标题的速成书，只是让你走马观花的瞧一下，绝非深入的理解。18世纪的英国诗人亚历山大·蒲柏[……1]曾说过：“一知半解”是一件危险的事情。[……1]：这个哥哥还给牛顿写了最出名的墓志铭之一：“自然和自然律隐没在黑暗中；上帝说，让牛顿去吧！遂一片光明。”<br><strong>C++</strong>: In 24 hours you might be able to learn some of the syntax of C++ (if you already know another language), but you couldn’t learn much about how to use the language. In short, if you were, say, a Basic programmer, you could learn to write programs in the style of Basic using C++ syntax, but you couldn’t learn what C++ is actually good (and bad) for. So what’s the point? Alan Perlis once said: “A language that doesn’t affect the way you think about programming, is not worth knowing”. One possible point is that you have to learn a tiny bit of C++ (or more likely, something like JavaScript or Processing) because you need to interface with an existing tool to accomplish a specific task. But then you’re not learning how to program; you’re learning to accomplish that task.<br><strong>C++</strong>: (如果你有一定的编程基础)，在24小时之内，能学会一些C++的语法，但是，仅此而已了。如果你以前是个Basic语言的程序员，你可以写一些语法是C++，但是风格是Basic的程序，但是，24小时之内，C++语言的精华或糟粕，你都学不到。重点是什么？(首界图灵奖得主)Alan Perlis曾说过：“不能影响你编程思维方式的语言，是不值得学习的。”一个更加可能的场景是，在工作中，你不得不学习C++（或者JavaScript，Processing之类）的一小部分，来调用一些原有的接口，完成某个特定的任务。这种情况下，表面上说是在学习如何编程，其实只是在应付一下手上的活。<br><strong>in 24 Hours</strong>: Unfortunately, this is not enough, as the next section shows.<br><strong>24小时内</strong>:很不幸，24小时太少了，原因下面告诉你。</p><h3 id="Teach-Yourself-Programming-in-Ten-Years-1"><a href="#Teach-Yourself-Programming-in-Ten-Years-1" class="headerlink" title="Teach Yourself Programming in Ten Years"></a>Teach Yourself Programming in Ten Years</h3><h3 id="十年学会编程"><a href="#十年学会编程" class="headerlink" title="十年学会编程"></a>十年学会编程</h3><p>Researchers (Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)) have shown it takes about ten years to develop expertise in any of a wide variety of areas, including chess playing, music composition, telegraph operation, painting, piano playing, swimming, tennis, and research in neuropsychology and topology. The key is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again. There appear to be no real shortcuts: even Mozart, who was a musical prodigy at age 4, took 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the scene with a string of #1 hits and an appearance on the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critical success, Sgt. Peppers, was released in 1967.</p><p>研究表明，想在任何领域成为专家，大概需要10年的时间，这些领域包括下棋，作曲，发电报，弹钢琴，游泳，打网球，研究神经心理学和拓扑学。关键在于有针对性的训练，而不是漫无目的重复，训练的内容要刚好超过你现有的水平，练习以后要分析你的表现，改正发现的错误，然后重复，再重复。没有什么捷径可走，即使是Mozart，一个4岁就能弹琴的音乐天才，也是用了13年的时间，才真正的写出世界级的音乐作品。在流行音乐上，Beatles好像是在1964年访美期间一夜成名的。实际上，他们从1957年就已经开始在利物浦和汉堡的小酒馆里唱歌了，他们组建乐队的时间就更早了，他们第一张取得巨大成功的专辑《佩帕军士》，是在1967年发行的。</p><p>Malcolm Gladwell has popularized the idea, although he concentrates on 10,000 hours, not 10 years. Henri Cartier-Bresson (1908-2004) had another metric: “Your first 10,000 photographs are your worst.” (He didn’t anticipate that with digital cameras, some people can reach that mark in a week.) True expertise may take a lifetime: Samuel Johnson (1709-1784) said “Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price.” And Chaucer (1340-1400) complained “the lyf so short, the craft so long to lerne.” Hippocrates (c. 400BC) is known for the excerpt “ars longa, vita brevis”, which is part of the longer quotation “Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”, which in English renders as “Life is short, [the] craft long, opportunity fleeting, experiment treacherous, judgment difficult.” Of course, no single number can be the final answer: it doesn’t seem reasonable to assume that all skills (e.g., programming, chess playing, checkers playing, and music playing) could all require exactly the same amount of time to master, nor that all people will take exactly the same amount of time. As Prof. K. Anders Ericsson puts it, “In most domains it’s remarkable how much time even the most talented individuals need in order to reach the highest levels of performance. The 10,000 hour number just gives you a sense that we’re talking years of 10 to 20 hours a week which those who some people would argue are the most innately talented individuals still need to get to the highest level.”</p><p>马尔科姆·格拉德威尔让这个理论广为人知，虽然他说的是另一个说法，10，000个小时而不是10年(这本书有中文翻译版异类 : 不一样的成功启示录)。法国现实主义摄影大师亨利·卡蒂埃-布列松有另外一个标准，他说你的前10,000张照片是你最差的。(当然，这个摄影大师没有意识到数码相机的出现，很多人能在一周内就可以拍10,000张照片)真正的大师要用一生来完成，英国作家，文学评论家和诗人塞缪尔·约翰逊说过：“在任何领域取得卓越的成就都要用一生的努力，不要妄想可以投机取巧。”英国的诗人乔叟也曾经说过：”吾生也有涯 而知也无涯。”同样，公元前400年的希波克拉底也表达过类似的意思，他也认为艺术没有止境，生命却有尽头。他说的这句话有个更长的版本，翻译成英语的意思是：“生命有尽头，艺术无止境，机遇转瞬即逝，练功走火入魔，决定优柔寡断。”当然，不会有一个确定的答案告诉你需要多长时间，毕竟，假设掌握所有的技能(比如编程，下棋，跳棋和音乐)需要相同的时间也不合适，不同的人也会用不同的时间。K.Anders Ericsson教授说过：“值得注意的是，在大多数领域，即使你是个天才，要达到专家级别的高水平仍然需要时间。10，000个小时只是给你一个概念，一个天才，如果每周练习10到20个小时的时间，仍然需要数年时间才能达到专家级别的水平。”</p><h3 id="So-You-Want-to-be-a-Programmer"><a href="#So-You-Want-to-be-a-Programmer" class="headerlink" title="So You Want to be a Programmer"></a>So You Want to be a Programmer</h3><h3 id="所以你想成为一个程序员"><a href="#所以你想成为一个程序员" class="headerlink" title="所以你想成为一个程序员"></a>所以你想成为一个程序员</h3><p>Here’s my recipe for programming success:</p><p>这是我编程成功的秘笈:</p><p>Get interested in programming, and do some because it is fun. Make sure that it keeps being enough fun so that you will be willing to put in your ten years/10,000 hours.</p><p>要对编程感兴趣，要从中能获得快乐。保证编程足够有趣，这样才能让你花10年的时间或者10，000个小时在上面也不觉得枯燥无味。</p><p>Program. The best kind of learning is learning by doing. To put it more technically, “the maximal level of performance for individuals in a given domain is not attained automatically as a function of extended experience, but the level of performance can be increased even by highly experienced individuals as a result of deliberate efforts to improve.” (p. 366) and “the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors.” (p. 20-21) The book Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life is an interesting reference for this viewpoint.</p><p>动手编程。最好的学习方法是边学边做。常言道：“人的最高功力并不能通过做一天和尚撞一天钟这样的重复经验获得，但是，最高的功力可以通过有针对性的日复一日年复一年的训练来获得。”并且，“最有效果的学习需要有针对性的任务，这些任务的难度还要因人而异，并且有合理的反馈渠道，并能够根据这些反馈作出相应的改进。”这些观点引用自《Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life》这本书里。</p><p>Talk with other programmers; read other programs. This is more important than any book or training course.</p><p>和其他的程序员交流；阅读别人的代码。这比看书或者参加培训课程要重要。</p><p>If you want, put in four years at a college (or more at a graduate school). This will give you access to some jobs that require credentials, and it will give you a deeper understanding of the field, but if you don’t enjoy school, you can (with some dedication) get similar experience on your own or on the job. In any case, book learning alone won’t be enough. “Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter” says Eric Raymond, author of The New Hacker’s Dictionary. One of the best programmers I ever hired had only a High School degree; he’s produced a lot of greatsoftware, has his own news group, and made enough in stock options to buy his own nightclub.</p><p>如果你愿意，在大学里花上四年时间（或者再读个研）。这能让你获得一些工作机会，也能让你在这个领域有更深入的了解。但是，如果你一上学就头痛，直接去工作也能获得相同的经验。无论是什么情况，读死书肯定是不行的。计算机科学不会让你成为编程专家，就像学习画笔和颜料不可能让你成为画家一样。这是Eric　Raymond说的，他是New Hacker’s Dictionary字典的作者。我雇佣过的最好的程序员是个高中毕业的学生，他创造了伟大的软件，Mozilla，他拥有自己的新闻组，赚到了足够多的钱买了自己的酒吧。</p><p>Work on projects with other programmers. Be the best programmer on some projects; be the worst on some others. When you’re the best, you get to test your abilities to lead a project, and to inspire others with your vision. When you’re the worst, you learn what the masters do, and you learn what they don’t like to do (because they make you do it for them).</p><p>和其他的程序员一起参与一些项目。在一些项目中成为最出色的程序员；在另一些项目中当最差劲的程序员。在当最出色的程序员的时候，要测试你领导项目的能力，用你的视野来启发别人。如果你是项目中最差的那个，要学习牛人们在做什么，如果他们不喜欢做的，你要拿来做。</p><p>Work on projects after other programmers. Understand a program written by someone else. See what it takes to understand and fix it when the original programmers are not around. Think about how to design your programs to make it easier for those who will maintain them after you.</p><p>接手并推进别人的项目。理解其他人写的代码。如果别人有没有考虑到的问题，你能理解并修复这些问题。思考并设计你的软件，让这些软件容易被他人维护。</p><p>Learn at least a half dozen programming languages. Include one language that emphasizes class abstractions (like Java or C++), one that emphasizes functional abstraction (like Lisp or ML or Haskell), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), and one that emphasizes parallelism (like Clojure or Go).</p><p>学习至少6种(我不太清楚英语中的half dozen是什么意思，是虚指还是就是6种)编程语言。这6种语言中，包括一种支持抽象类的(例如Java或者C++)，一种支持函数的(Lisp, ML或者Haskell)，一种支持语义抽象的(Lisp)，一种支持声明规范的(Prolog或者C++模板)，还有一种支持并发的(Clojure或Go)。</p><p>Remember that there is a “computer“ in “computer science”. Know how long it takes your computer to execute an instruction, fetch a word from memory (with and without a cache miss), read consecutive words from disk, and seek to a new location on disk. (Answers here.)</p><p>记住，在“计算机科学”中在“计算机”这个词语。理解执行一条指令要花多长时间，从内存中取一个字（要考虑缓存有没有命中的情况）要多久，从硬盘中连续读字节要多久，在硬盘中寻址定位要多久？</p><p>Get involved in a language standardization effort. It could be the ANSI C++ committee, or it could be deciding if your local coding style will have 2 or 4 space indentation levels. Either way, you learn about what other people like in a language, how deeply they feel so, and perhaps even a little about why they feel so.</p><p>参加语言的标准化工作。这可能是有关 ANSI C++ 委员会，也可能是缩进的风格是两格缩进或四格缩进。无论如何，你能从中学到其他人对语言的喜好，也能了解到他们热爱的程度，甚至也许能知道一点他们为什么他们会这样认为？</p><p>Have the good sense to get off the language standardization effort as quickly as possible.</p><p>知道何时能从标准化语言的工作中脱身，越快越好。</p><p>With all that in mind, its questionable how far you can get just by book learning. Before my first child was born, I read all the How To books, and still felt like a clueless novice. 30 Months later, when my second child was due, did I go back to the books for a refresher? No. Instead, I relied on my personal experience, which turned out to be far more useful and reassuring to me than the thousands of pages written by experts.</p><p>很难说能从书本中学到多少东西。我第一个小孩出生的时候，我读了所有的“如何做”系列的书，但是，没有什么头绪。30个月以后，当我的第二个孩子出生，我还要重温一下那些书么？当然不用了！我都已经是老司机了，我完全靠我自己的经验，事实也证明我自己的经验要胜过那些专家们写的上千页的书。</p><p>Fred Brooks, in his essay No Silver Bullet identified a three-part plan for finding great software designers:</p><p>弗雷德·布鲁克斯在他的书《没有银弹》中给出了三条建议：</p><p>Systematically identify top designers as early as possible.</p><p>尽早地系统地识别出顶级设计师</p><p>Assign a career mentor to be responsible for the development of the prospect and carefully keep a career file.</p><p>每个人给分配一个职业规划的导师</p><p>Provide opportunities for growing designers to interact and stimulate each other.</p><p>让成长中的设计师有机会互相切磋武艺</p><p>This assumes that some people already have the qualities necessary for being a great designer; the job is to properly coax them along. Alan Perlis put it more succinctly: “Everyone can be taught to sculpt: Michelangelo would have had to be taught how not to. So it is with the great programmers”. Perlis is saying that the greats have some internal quality that transcends their training. But where does the quality come from? Is it innate? Or do they develop it through diligence? As Auguste Gusteau (the fictional chef in Ratatouille) puts it, “anyone can cook, but only the fearless can be great.” I think of it more as willingness to devote a large portion of one’s life to deliberative practice. But maybe fearless is a way to summarize that. Or, as Gusteau’s critic, Anton Ego, says: “Not everyone can become a great artist, but a great artist can come from anywhere.”</p><p>此处假设有一些人天生有成为伟大设计师的潜质，然后，就是正确的去引导他们。艾伦·佩里斯一针见血地说：”假如每个人都可以学会雕刻，那就得教米开朗基罗哪些事不要去做。对于伟大程序员，也是如此。”Perlis认为，伟大的人有一种内在的特质，这种特质往往比接受训练更重要。但是，这些特质是从哪里来的呢？与生俱来的？还是通过后天勤奋而来的？正如 动画片《料理鼠王》里的幻象大厨Auguste Gusteau说的那样：“谁都能做饭，但只有那些无所畏惧的人才能成为大厨！”我认为“把你生命中的大部分时间花在有针对性的练习上”这种精神，看作一种自愿奉献的精神！但或许“无所畏惧”才是体现这种精神的真谛。或者，就像是《料理鼠王》里那个与 Gusteau 作对的刻薄的美食评论家 Anton Ego 说的那样：“不是任何人都能成为伟大的艺术家，不过，伟大的艺术家可以来自任何地方。”</p><p>So go ahead and buy that Java/Ruby/Javascript/PHP book; you’ll probably get some use out of it. But you won’t change your life, or your real overall expertise as a programmer in 24 hours or 21 days. How about working hard to continually improve over 24 months? Well, now you’re starting to get somewhere…</p><p>所以，尽管买本 Java/Ruby/Javascript/PHP 的书吧。你可能会从中学到点儿有用的东西。但作为一个程序员，在 21 天内或 24 小时内改变你的人生，或者提高你实际的编程水平，这是不可能的。你尝试过连续 24 个月不间断的努力提高自己么？好吧，好吧，你该上路了……</p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么学生不喜欢上学</title>
      <link href="/2018/12/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/"/>
      <url>/2018/12/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么学生不喜欢上学"><a href="#为什么学生不喜欢上学" class="headerlink" title="为什么学生不喜欢上学"></a>为什么学生不喜欢上学</h3><p>   用你的梦想和理想引领你的一生，要用感恩真诚助人圆梦的心态引领你的一生，要用执着无惧乐观的态度引领你的一生。如果你做到了这些，因缘会给你一切你所应得的。<br>   不要被信条所惑，盲从信条就是活在别人思考的结果里。不要让别人的意见淹没了你内在的心声。最重要的，拥有跟随内心与直觉的勇气，你的内心与直觉多少已经知道那你真正想要成为什么样的人，任何其他事物都是次要的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李开复自传</title>
      <link href="/2018/12/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/12/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="价值不是你拥有多少-而是你留下多少"><a href="#价值不是你拥有多少-而是你留下多少" class="headerlink" title="价值不是你拥有多少,而是你留下多少."></a>价值不是你拥有多少,而是你留下多少.</h3><p>   用你的梦想和理想引领你的一生，要用感恩真诚助人圆梦的心态引领你的一生，要用执着无惧乐观的态度引领你的一生。如果你做到了这些，因缘会给你一切你所应得的。<br>   不要被信条所惑，盲从信条就是活在别人思考的结果里。不要让别人的意见淹没了你内在的心声。最重要的，拥有跟随内心与直觉的勇气，你的内心与直觉多少已经知道那你真正想要成为什么样的人，任何其他事物都是次要的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自传 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
