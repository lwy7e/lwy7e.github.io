<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP函数]]></title>
    <url>%2F2019%2F07%2F03%2FPHP%2Fphp%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[我在正文开头定义了一个： 数组字符串多字节字符串变量处理文件系统目录处理数学类和对象字符类型检测日期和时间CURL过滤器函数处理正则处理网络程序执行PHP选项和信息错误处理输出缓冲控制密码散列算法SessionJSONStreamSPLBCMath杂项数组 array_change_key_case — 将数组中的所有键名修改为全大写或小写 array_chunk — 将一个数组分割成多个 array_column — 返回数组中指定的一列 array_combine — 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值 array_count_values — 统计数组中所有的值 array_diff_assoc — 带索引检查计算数组的差集 array_diff_key — 使用键名比较计算数组的差集 array_diff_uassoc — 用用户提供的回调函数做索引检查来计算数组的差集 array_diff_ukey — 用回调函数对键名比较计算数组的差集 array_diff — 计算数组的差集 array_fill_keys — 使用指定的键和值填充数组 array_fill — 用给定的值填充数组 array_filter — 用回调函数过滤数组中的单元 array_flip — 交换数组中的键和值 array_intersect_assoc — 带索引检查计算数组的交集 array_intersect_key — 使用键名比较计算数组的交集 array_intersect_uassoc — 带索引检查计算数组的交集，用回调函数比较索引 array_intersect_ukey — 用回调函数比较键名来计算数组的交集 array_intersect — 计算数组的交集 array_key_exists — 检查数组里是否有指定的键名或索引 array_key_first — Gets the first key of an array array_key_last — Gets the last key of an array array_keys — 返回数组中部分的或所有的键名 array_map — 为数组的每个元素应用回调函数 array_merge_recursive — 递归地合并一个或多个数组 array_merge — 合并一个或多个数组 array_multisort — 对多个数组或多维数组进行排序 array_pad — 以指定长度将一个值填充进数组 array_pop — 弹出数组最后一个单元（出栈） array_product — 计算数组中所有值的乘积 array_push — 将一个或多个单元压入数组的末尾（入栈） array_rand — 从数组中随机取出一个或多个单元 array_reduce — 用回调函数迭代地将数组简化为单一的值 array_replace_recursive — 使用传递的数组递归替换第一个数组的元素 array_replace — 使用传递的数组替换第一个数组的元素 array_reverse — 返回单元顺序相反的数组 array_search — 在数组中搜索给定的值，如果成功则返回首个相应的键名 array_shift — 将数组开头的单元移出数组 array_slice — 从数组中取出一段 array_splice — 去掉数组中的某一部分并用其它值取代 array_sum — 对数组中所有值求和 array_udiff_assoc — 带索引检查计算数组的差集，用回调函数比较数据 array_udiff_uassoc — 带索引检查计算数组的差集，用回调函数比较数据和索引 array_udiff — 用回调函数比较数据来计算数组的差集 array_uintersect_assoc — 带索引检查计算数组的交集，用回调函数比较数据 array_uintersect_uassoc — 带索引检查计算数组的交集，用单独的回调函数比较数据和索引 array_uintersect — 计算数组的交集，用回调函数比较数据 array_unique — 移除数组中重复的值 array_unshift — 在数组开头插入一个或多个单元 array_values — 返回数组中所有的值 array_walk_recursive — 对数组中的每个成员递归地应用用户函数 array_walk — 使用用户自定义函数对数组中的每个元素做回调处理 array — 新建一个数组 arsort — 对数组进行逆向排序并保持索引关系 asort — 对数组进行排序并保持索引关系 compact — 建立一个数组，包括变量名和它们的值 count — 计算数组中的单元数目，或对象中的属性个数 current — 返回数组中的当前单元 each — 返回数组中当前的键／值对并将数组指针向前移动一步 end — 将数组的内部指针指向最后一个单元 extract — 从数组中将变量导入到当前的符号表 in_array — 检查数组中是否存在某个值 key_exists — 别名 array_key_exists key — 从关联数组中取得键名 krsort — 对数组按照键名逆向排序 ksort — 对数组按照键名排序 list — 把数组中的值赋给一组变量 natcasesort — 用&ldquo;自然排序&rdquo;算法对数组进行不区分大小写字母的排序 natsort — 用&ldquo;自然排序&rdquo;算法对数组排序 next — 将数组中的内部指针向前移动一位 pos — current 的别名 prev — 将数组的内部指针倒回一位 range — 根据范围创建数组，包含指定的元素 reset — 将数组的内部指针指向第一个单元 rsort — 对数组逆向排序 shuffle — 打乱数组 sizeof — count 的别名 sort — 对数组排序 uasort — 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 uksort — 使用用户自定义的比较函数对数组中的键名进行排序 usort — 使用用户自定义的比较函数对数组中的值进行排序 字符串 addcslashes — 以 C 语言风格使用反斜线转义字符串中的字符 addslashes — 使用反斜线引用字符串 bin2hex — 函数把包含数据的二进制字符串转换为十六进制值 chop — rtrim 的别名 chr — 返回指定的字符 chunk_split — 将字符串分割成小块 convert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种 convert_uudecode — 解码一个 uuencode 编码的字符串 convert_uuencode — 使用 uuencode 编码一个字符串 count_chars — 返回字符串所用字符的信息 crc32 — 计算一个字符串的 crc32 多项式 crypt — 单向字符串散列 echo — 输出一个或多个字符串 explode — 使用一个字符串分割另一个字符串 fprintf — 将格式化后的字符串写入到流 get_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表 hebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew） hebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符 hex2bin — 转换十六进制字符串为二进制字符串 html_entity_decode — Convert HTML entities to their corresponding characters htmlentities — 将字符转换为 HTML 转义字符 htmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符 htmlspecialchars — 将特殊字符转换为 HTML 实体 implode — 将一个一维数组的值转化为字符串 join — 别名 implode lcfirst — 使一个字符串的第一个字符小写 levenshtein — 计算两个字符串之间的编辑距离 localeconv — Get numeric formatting information ltrim — 删除字符串开头的空白字符（或其他字符） md5_file — 计算指定文件的 MD5 散列值 md5 — 计算字符串的 MD5 散列值 metaphone — Calculate the metaphone key of a string money_format — 将数字格式化成货币字符串 nl_langinfo — Query language and locale information nl2br — 在字符串所有新行之前插入 HTML 换行标记 number_format — 以千位分隔符方式格式化一个数字 ord — 转换字符串第一个字节为 0-255 之间的值 parse_str — 将字符串解析成多个变量 print — 输出字符串 printf — 输出格式化字符串 quoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串 quoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串 quotemeta — 转义元字符集 rtrim — 删除字符串末端的空白字符（或者其他字符） setlocale — 设置地区信息 sha1_file — 计算文件的 sha1 散列值 sha1 — 计算字符串的 sha1 散列值 similar_text — 计算两个字符串的相似度 soundex — Calculate the soundex key of a string sprintf — Return a formatted string sscanf — 根据指定格式解析输入的字符 str_getcsv — 解析 CSV 字符串为一个数组 str_ireplace — str_replace 的忽略大小写版本 str_pad — 使用另一个字符串填充字符串为指定长度 str_repeat — 重复一个字符串 str_replace — 子字符串替换 str_rot13 — 对字符串执行 ROT13 转换 str_shuffle — 随机打乱一个字符串 str_split — 将字符串转换为数组 str_word_count — 返回字符串中单词的使用情况 strcasecmp — 二进制安全比较字符串（不区分大小写） strchr — 别名 strstr strcmp — 二进制安全字符串比较 strcoll — 基于区域设置的字符串比较 strcspn — 获取不匹配遮罩的起始子字符串的长度 strip_tags — 从字符串中去除 HTML 和 PHP 标记 stripcslashes — 反引用一个使用 addcslashes 转义的字符串 stripos — 查找字符串首次出现的位置（不区分大小写） stripslashes — 反引用一个引用字符串 stristr — strstr 函数的忽略大小写版本 strlen — 获取字符串长度 strnatcasecmp — 使用&ldquo;自然顺序&rdquo;算法比较字符串（不区分大小写） strnatcmp — 使用自然排序算法比较字符串 strncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写） strncmp — 二进制安全比较字符串开头的若干个字符 strpbrk — 在字符串中查找一组字符的任何一个字符 strpos — 查找字符串首次出现的位置 strrchr — 查找指定字符在字符串中的最后一次出现 strrev — 反转字符串 strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写） strrpos — 计算指定字符串在目标字符串中最后一次出现的位置 strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。 strstr — 查找字符串的首次出现 strtok — 标记分割字符串 strtolower — 将字符串转化为小写 strtoupper — 将字符串转化为大写 strtr — 转换指定字符 substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度） substr_count — 计算字串出现的次数 substr_replace — 替换字符串的子串 substr — 返回字符串的子串 trim — 去除字符串首尾处的空白字符（或者其他字符） ucfirst — 将字符串的首字母转换为大写 ucwords — 将字符串中每个单词的首字母转换为大写 vfprintf — 将格式化字符串写入流 vprintf — 输出格式化字符串 vsprintf — 返回格式化字符串 wordwrap — 打断字符串为指定数量的字串 多字节字符串 mb_check_encoding — 检查字符串在指定的编码里是否有效 mb_chr — Get a specific character mb_convert_case — 对字符串进行大小写转换 mb_convert_encoding — 转换字符的编码 mb_convert_kana — Convert &quot;kana&quot; one from another (&quot;zen-kaku&quot;, &quot;han-kaku&quot; and more) mb_convert_variables — 转换一个或多个变量的字符编码 mb_decode_mimeheader — 解码 MIME 头字段中的字符串 mb_decode_numericentity — 根据 HTML 数字字符串解码成字符 mb_detect_encoding — 检测字符的编码 mb_detect_order — 设置/获取 字符编码的检测顺序 mb_encode_mimeheader — 为 MIME 头编码字符串 mb_encode_numericentity — Encode character to HTML numeric string reference mb_encoding_aliases — Get aliases of a known encoding type mb_ereg_match — Regular expression match for multibyte string mb_ereg_replace_callback — Perform a regular expression search and replace with multibyte support using a callback mb_ereg_replace — Replace regular expression with multibyte support mb_ereg_search_getpos — Returns start point for next regular expression match mb_ereg_search_getregs — Retrieve the result from the last multibyte regular expression match mb_ereg_search_init — Setup string and regular expression for a multibyte regular expression match mb_ereg_search_pos — Returns position and length of a matched part of the multibyte regular expression for a predefined multibyte string mb_ereg_search_regs — Returns the matched part of a multibyte regular expression mb_ereg_search_setpos — Set start point of next regular expression match mb_ereg_search — Multibyte regular expression match for predefined multibyte string mb_ereg — Regular expression match with multibyte support mb_eregi_replace — Replace regular expression with multibyte support ignoring case mb_eregi — Regular expression match ignoring case with multibyte support mb_get_info — 获取 mbstring 的内部设置 mb_http_input — 检测 HTTP 输入字符编码 mb_http_output — 设置/获取 HTTP 输出字符编码 mb_internal_encoding — 设置/获取内部字符编码 mb_language — 设置/获取当前的语言 mb_list_encodings — 返回所有支持编码的数组 mb_ord — Get code point of character mb_output_handler — 在输出缓冲中转换字符编码的回调函数 mb_parse_str — 解析 GET/POST/COOKIE 数据并设置全局变量 mb_preferred_mime_name — 获取 MIME 字符串 mb_regex_encoding — Set/Get character encoding for multibyte regex mb_regex_set_options — Set/Get the default options for mbregex functions mb_scrub — Description mb_send_mail — 发送编码过的邮件 mb_split — 使用正则表达式分割多字节字符串 mb_strcut — 获取字符的一部分 mb_strimwidth — 获取按指定宽度截断的字符串 mb_stripos — 大小写不敏感地查找字符串在另一个字符串中首次出现的位置 mb_stristr — 大小写不敏感地查找字符串在另一个字符串里的首次出现 mb_strlen — 获取字符串的长度 mb_strpos — 查找字符串在另一个字符串中首次出现的位置 mb_strrchr — 查找指定字符在另一个字符串中最后一次的出现 mb_strrichr — 大小写不敏感地查找指定字符在另一个字符串中最后一次的出现 mb_strripos — 大小写不敏感地在字符串中查找一个字符串最后出现的位置 mb_strrpos — 查找字符串在一个字符串中最后出现的位置 mb_strstr — 查找字符串在另一个字符串里的首次出现 mb_strtolower — 使字符串小写 mb_strtoupper — 使字符串大写 mb_strwidth — 返回字符串的宽度 mb_substitute_character — 设置/获取替代字符 mb_substr_count — 统计字符串出现的次数 mb_substr — 获取部分字符串 变量处理 boolval — 获取变量的布尔值 debug_zval_dump — Dumps a string representation of an internal zend value to output doubleval — floatval 的别名 empty — 检查一个变量是否为空 floatval — 获取变量的浮点值 get_defined_vars — 返回由所有已定义变量所组成的数组 get_resource_type — 返回资源（resource）类型 gettype — 获取变量的类型 import_request_variables — 将 GET／POST／Cookie 变量导入到全局作用域中 intval — 获取变量的整数值 is_array — 检测变量是否是数组 is_bool — 检测变量是否是布尔型 is_callable — 检测参数是否为合法的可调用结构 is_countable — Verify that the contents of a variable is a countable value is_double — is_float 的别名 is_float — 检测变量是否是浮点型 is_int — 检测变量是否是整数 is_integer — is_int 的别名 is_iterable — Verify that the contents of a variable is an iterable value is_long — is_int 的别名 is_null — 检测变量是否为 NULL is_numeric — 检测变量是否为数字或数字字符串 is_object — 检测变量是否是一个对象 is_real — is_float 的别名 is_resource — 检测变量是否为资源类型 is_scalar — 检测变量是否是一个标量 is_string — 检测变量是否是字符串 isset — 检测变量是否已设置并且非 NULL print_r — 以易于理解的格式打印变量。 serialize — 产生一个可存储的值的表示 settype — 设置变量的类型 strval — 获取变量的字符串值 unserialize — 从已存储的表示中创建 PHP 的值 unset — 释放给定的变量 var_dump — 打印变量的相关信息 var_export — 输出或返回一个变量的字符串表示 文件系统 basename — 返回路径中的文件名部分 chgrp — 改变文件所属的组 chmod — 改变文件模式 chown — 改变文件的所有者 clearstatcache — 清除文件状态缓存 copy — 拷贝文件 delete — 参见 unlink 或 unset dirname — 返回路径中的目录部分 disk_free_space — 返回目录中的可用空间 disk_total_space — 返回一个目录的磁盘总大小 diskfreespace — disk_free_space 的别名 fclose — 关闭一个已打开的文件指针 feof — 测试文件指针是否到了文件结束的位置 fflush — 将缓冲内容输出到文件 fgetc — 从文件指针中读取字符 fgetcsv — 从文件指针中读入一行并解析 CSV 字段 fgets — 从文件指针中读取一行 fgetss — 从文件指针中读取一行并过滤掉 HTML 标记 file_exists — 检查文件或目录是否存在 file_get_contents — 将整个文件读入一个字符串 file_put_contents — 将一个字符串写入文件 file — 把整个文件读入一个数组中 fileatime — 取得文件的上次访问时间 filectime — 取得文件的 inode 修改时间 filegroup — 取得文件的组 fileinode — 取得文件的 inode filemtime — 取得文件修改时间 fileowner — 取得文件的所有者 fileperms — 取得文件的权限 filesize — 取得文件大小 filetype — 取得文件类型 flock — 轻便的咨询文件锁定 fnmatch — 用模式匹配文件名 fopen — 打开文件或者 URL fpassthru — 输出文件指针处的所有剩余数据 fputcsv — 将行格式化为 CSV 并写入文件指针 fputs — fwrite 的别名 fread — 读取文件（可安全用于二进制文件） fscanf — 从文件中格式化输入 fseek — 在文件指针中定位 fstat — 通过已打开的文件指针取得文件信息 ftell — 返回文件指针读/写的位置 ftruncate — 将文件截断到给定的长度 fwrite — 写入文件（可安全用于二进制文件） glob — 寻找与模式匹配的文件路径 is_dir — 判断给定文件名是否是一个目录 is_executable — 判断给定文件名是否可执行 is_file — 判断给定文件名是否为一个正常的文件 is_link — 判断给定文件名是否为一个符号连接 is_readable — 判断给定文件名是否可读 is_uploaded_file — 判断文件是否是通过 HTTP POST 上传的 is_writable — 判断给定的文件名是否可写 is_writeable — is_writable 的别名 lchgrp — 修改符号链接的所有组 lchown — 修改符号链接的所有者 link — 建立一个硬连接 linkinfo — 获取一个连接的信息 lstat — 给出一个文件或符号连接的信息 mkdir — 新建目录 move_uploaded_file — 将上传的文件移动到新位置 parse_ini_file — 解析一个配置文件 parse_ini_string — 解析配置字符串 pathinfo — 返回文件路径的信息 pclose — 关闭进程文件指针 popen — 打开进程文件指针 readfile — 输出文件 readlink — 返回符号连接指向的目标 realpath_cache_get — 获取真实目录缓存的详情 realpath_cache_size — 获取真实路径缓冲区的大小 realpath — 返回规范化的绝对路径名 rename — 重命名一个文件或目录 rewind — 倒回文件指针的位置 rmdir — 删除目录 set_file_buffer — stream_set_write_buffer 的别名 stat — 给出文件的信息 symlink — 建立符号连接 tempnam — 建立一个具有唯一文件名的文件 tmpfile — 建立一个临时文件 touch — 设定文件的访问和修改时间 umask — 改变当前的 umask unlink — 删除文件 目录处理 chdir — 改变目录 chroot — 改变根目录 closedir — 关闭目录句柄 dir — 返回一个 Directory 类实例 getcwd — 取得当前工作目录 opendir — 打开目录句柄 readdir — 从目录句柄中读取条目 rewinddir — 倒回目录句柄 scandir — 列出指定路径中的文件和目录 数学 abs — 绝对值 acos — 反余弦 acosh — 反双曲余弦 asin — 反正弦 asinh — 反双曲正弦 atan2 — 两个参数的反正切 atan — 反正切 atanh — 反双曲正切 base_convert — 在任意进制之间转换数字 bindec — 二进制转换为十进制 ceil — 进一法取整 cos — 余弦 cosh — 双曲余弦 decbin — 十进制转换为二进制 dechex — 十进制转换为十六进制 decoct — 十进制转换为八进制 deg2rad — 将角度转换为弧度 exp — 计算 e 的指数 expm1 — 返回 exp(number) - 1，甚至当 number 的值接近零也能计算出准确结果 floor — 舍去法取整 fmod — 返回除法的浮点数余数 getrandmax — 显示随机数最大的可能值 hexdec — 十六进制转换为十进制 hypot — 计算一直角三角形的斜边长度 intdiv — 对除法结果取整 is_finite — 判断是否为有限值 is_infinite — 判断是否为无限值 is_nan — 判断是否为合法数值 lcg_value — 组合线性同余发生器 log10 — 以 10 为底的对数 log1p — 返回 log(1 + number)，甚至当 number 的值接近零也能计算出准确结果 log — 自然对数 max — 找出最大值 min — 找出最小值 mt_getrandmax — 显示随机数的最大可能值 mt_rand — 生成更好的随机数 mt_srand — 播下一个更好的随机数发生器种子 octdec — 八进制转换为十进制 pi — 得到圆周率值 pow — 指数表达式 rad2deg — 将弧度数转换为相应的角度数 rand — 产生一个随机整数 round — 对浮点数进行四舍五入 sin — 正弦 sinh — 双曲正弦 sqrt — 平方根 srand — 播下随机数发生器种子 tan — 正切 tanh — 双曲正切 类和对象 __autoload — 尝试加载未定义的类 call_user_method_array — 以参数列表的数组，调用用户方法 call_user_method — 对特定对象调用用户方法 class_alias — 为一个类创建别名 class_exists — 检查类是否已定义 get_called_class — 后期静态绑定（&quot;Late Static Binding&quot;）类的名称 get_class_methods — 返回由类的方法名组成的数组 get_class_vars — 返回由类的默认属性组成的数组 get_class — 返回对象的类名 get_declared_classes — 返回由已定义类的名字所组成的数组 get_declared_interfaces — 返回一个数组包含所有已声明的接口 get_declared_traits — 返回所有已定义的 traits 的数组 get_object_vars — 返回由对象属性组成的关联数组 get_parent_class — 返回对象或类的父类名 interface_exists — 检查接口是否已被定义 is_a — 如果对象属于该类或该类是此对象的父类则返回 TRUE is_subclass_of — 如果此对象是该类的子类，则返回 TRUE method_exists — 检查类的方法是否存在 property_exists — 检查对象或类是否具有该属性 trait_exists — 检查指定的 trait 是否存在 字符类型检测 ctype_alnum — 做字母和数字字符检测 ctype_alpha — 做纯字符检测 ctype_cntrl — 做控制字符检测 ctype_digit — 做纯数字检测 ctype_graph — 做可打印字符串检测，空格除外 ctype_lower — 做小写字符检测 ctype_print — 做可打印字符检测 ctype_punct — 检测可打印的字符是不是不包含空白、数字和字母 ctype_space — 做空白字符检测 ctype_upper — 做大写字母检测 ctype_xdigit — 检测字符串是否只包含十六进制字符 日期和时间 checkdate — 验证一个格里高里日期 date_add — 别名 DateTime::add date_create_from_format — 别名 DateTime::createFromFormat date_create_immutable_from_format — 别名 DateTimeImmutable::createFromFormat date_create_immutable — 别名 DateTimeImmutable::__construct date_create — 别名 DateTime::__construct date_date_set — 别名 DateTime::setDate date_default_timezone_get — 取得一个脚本中所有日期时间函数所使用的默认时区 date_default_timezone_set — 设定用于一个脚本中所有日期时间函数的默认时区 date_diff — 别名 DateTime::diff date_format — 别名 DateTime::format date_get_last_errors — 别名 DateTime::getLastErrors date_interval_create_from_date_string — 别名 DateInterval::createFromDateString date_interval_format — 别名 DateInterval::format date_isodate_set — 别名 DateTime::setISODate date_modify — 别名 DateTime::modify date_offset_get — 别名 DateTime::getOffset date_parse_from_format — Get info about given date formatted according to the specified format date_parse — Returns associative array with detailed info about given date date_sub — 别名 DateTime::sub date_sun_info — Returns an array with information about sunset/sunrise and twilight begin/end date_sunrise — 返回给定的日期与地点的日出时间 date_sunset — 返回给定的日期与地点的日落时间 date_time_set — 别名 DateTime::setTime date_timestamp_get — 别名 DateTime::getTimestamp date_timestamp_set — 别名 DateTime::setTimestamp date_timezone_get — 别名 DateTime::getTimezone date_timezone_set — 别名 DateTime::setTimezone date — 格式化一个本地时间／日期 getdate — 取得日期／时间信息 gettimeofday — 取得当前时间 gmdate — 格式化一个 GMT/UTC 日期／时间 gmmktime — 取得 GMT 日期的 UNIX 时间戳 gmstrftime — 根据区域设置格式化 GMT/UTC 时间／日期 idate — 将本地时间日期格式化为整数 localtime — 取得本地时间 microtime — 返回当前 Unix 时间戳和微秒数 mktime — 取得一个日期的 Unix 时间戳 strftime — 根据区域设置格式化本地时间／日期 strptime — 解析由 strftime 生成的日期／时间 strtotime — 将任何字符串的日期时间描述解析为 Unix 时间戳 time — 返回当前的 Unix 时间戳 timezone_abbreviations_list — 别名 DateTimeZone::listAbbreviations timezone_identifiers_list — 别名 DateTimeZone::listIdentifiers timezone_location_get — 别名 DateTimeZone::getLocation timezone_name_from_abbr — Returns the timezone name from abbreviation timezone_name_get — 别名 DateTimeZone::getName timezone_offset_get — 别名 DateTimeZone::getOffset timezone_open — 别名 DateTimeZone::__construct timezone_transitions_get — 别名 DateTimeZone::getTransitions timezone_version_get — Gets the version of the timezonedb CURL curl_close — 关闭 cURL 会话 curl_copy_handle — 复制一个cURL句柄和它的所有选项 curl_errno — 返回最后一次的错误代码 curl_error — 返回当前会话最后一次错误的字符串 curl_escape — 使用 URL 编码给定的字符串 curl_exec — 执行 cURL 会话 curl_file_create — 创建一个 CURLFile 对象 curl_getinfo — 获取一个cURL连接资源句柄的信息 curl_init — 初始化 cURL 会话 curl_multi_add_handle — 向curl批处理会话中添加单独的curl句柄 curl_multi_close — 关闭一组cURL句柄 curl_multi_errno — 返回上一次 curl 批处理的错误码 curl_multi_exec — 运行当前 cURL 句柄的子连接 curl_multi_getcontent — 如果设置了CURLOPT_RETURNTRANSFER，则返回获取的输出的文本流 curl_multi_info_read — 获取当前解析的cURL的相关传输信息 curl_multi_init — 返回一个新cURL批处理句柄 curl_multi_remove_handle — 移除cURL批处理句柄资源中的某个句柄资源 curl_multi_select — 等待所有cURL批处理中的活动连接 curl_multi_setopt — 为 cURL 并行处理设置一个选项 curl_multi_strerror — 返回字符串描述的错误代码 curl_pause — 暂停和取消暂停一个连接。 curl_reset — 重置一个 libcurl 会话句柄的所有的选项 curl_setopt_array — 为 cURL 传输会话批量设置选项 curl_setopt — 设置 cURL 传输选项 curl_share_close — 关闭 cURL 共享句柄 curl_share_errno — 返回共享 curl 句柄的最后一次错误号 curl_share_init — 初始化一个 cURL 共享句柄。 curl_share_setopt — 为 cURL 共享句柄设置选项。 curl_share_strerror — 返回错误号对应的错误消息 curl_strerror — 返回错误代码的字符串描述 curl_unescape — 解码给定的 URL 编码的字符串 curl_version — 获取 cURL 版本信息 过滤器 filter_has_var — 检测是否存在指定类型的变量 filter_id — 返回与某个特定名称的过滤器相关联的id filter_input_array — 获取一系列外部变量，并且可以通过过滤器处理它们 filter_input — 通过名称获取特定的外部变量，并且可以通过过滤器处理它 filter_list — 返回所支持的过滤器列表 filter_var_array — 获取多个变量并且过滤它们 filter_var — 使用特定的过滤器过滤一个变量 函数处理 call_user_func_array — 调用回调函数，并把一个数组参数作为回调函数的参数 call_user_func — 把第一个参数作为回调函数调用 create_function — Create an anonymous (lambda-style) function forward_static_call_array — Call a static method and pass the arguments as array forward_static_call — Call a static method func_get_arg — 返回参数列表的某一项 func_get_args — 返回一个包含函数参数列表的数组 func_num_args — Returns the number of arguments passed to the function function_exists — 如果给定的函数已经被定义就返回 TRUE get_defined_functions — 返回所有已定义函数的数组 register_shutdown_function — 注册一个会在php中止时执行的函数 register_tick_function — Register a function for execution on each tick unregister_tick_function — De-register a function for execution on each tick 正则处理 preg_filter — 执行一个正则表达式搜索和替换 preg_grep — 返回匹配模式的数组条目 preg_last_error — 返回最后一个PCRE正则执行产生的错误代码 preg_match_all — 执行一个全局正则表达式匹配 preg_match — 执行匹配正则表达式 preg_quote — 转义正则表达式字符 preg_replace_callback_array — Perform a regular expression search and replace using callbacks preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换 preg_replace — 执行一个正则表达式的搜索和替换 preg_split — 通过一个正则表达式分隔字符串 网络 checkdnsrr — 给指定的主机（域名）或者IP地址做DNS通信检查 closelog — 关闭系统日志链接 define_syslog_variables — Initializes all syslog related variables dns_check_record — 别名 checkdnsrr dns_get_mx — 别名 getmxrr dns_get_record — 获取指定主机的DNS记录 fsockopen — 打开一个网络连接或者一个Unix套接字连接 gethostbyaddr — 获取指定的IP地址对应的主机名 gethostbyname — 返回主机名对应的 IPv4地址。 gethostbynamel — 获取互联网主机名对应的 IPv4 地址列表 gethostname — 获取主机名 getmxrr — 获取互联网主机名对应的 MX 记录 getprotobyname — Get protocol number associated with protocol name getprotobynumber — Get protocol name associated with protocol number getservbyname — 获取互联网服务协议对应的端口 getservbyport — Get Internet service which corresponds to port and protocol header_register_callback — 调用一个 header 函数 header_remove — 删除之前设置的 HTTP 头 header — 发送原生 HTTP 头 headers_list — 返回已发送的 HTTP 响应头（或准备发送的） headers_sent — 检测 HTTP 头是否已经发送 http_response_code — 获取/设置响应的 HTTP 状态码 inet_ntop — Converts a packed internet address to a human readable representation inet_pton — Converts a human readable IP address to its packed in_addr representation ip2long — 将 IPV4 的字符串互联网协议转换成长整型数字 long2ip — 将长整型转化为字符串形式带点的互联网标准格式地址（IPV4） openlog — Open connection to system logger pfsockopen — 打开一个持久的网络连接或者Unix套接字连接。 setcookie — 发送 Cookie setrawcookie — 发送未经 URL 编码的 cookie socket_get_status — 别名 stream_get_meta_data socket_set_blocking — 别名 stream_set_blocking socket_set_timeout — 别名 stream_set_timeout syslog — Generate a system log message 程序执行 escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数 escapeshellcmd — shell 元字符转义 exec — 执行一个外部程序 passthru — 执行外部程序并且显示原始输出 proc_close — 关闭由 proc_open 打开的进程并且返回进程退出码 proc_get_status — 获取由 proc_open 函数打开的进程的信息 proc_nice — 修改当前进程的优先级 proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。 proc_terminate — 杀除由 proc_open 打开的进程 shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。 system — 执行外部程序，并且显示输出 PHP选项和信息 assert_options — 设置/获取断言的各种标志 assert — 检查一个断言是否为 FALSE cli_get_process_title — Returns the current process title cli_set_process_title — Sets the process title dl — 运行时载入一个 PHP 扩展 extension_loaded — 检查一个扩展是否已经加载 gc_collect_cycles — 强制收集所有现存的垃圾循环周期 gc_disable — 停用循环引用收集器 gc_enable — 激活循环引用收集器 gc_enabled — 返回循环引用计数器的状态 gc_mem_caches — Reclaims memory used by the Zend Engine memory manager gc_status — Gets information about the garbage collector get_cfg_var — 获取 PHP 配置选项的值 get_current_user — 获取当前 PHP 脚本所有者名称 get_defined_constants — 返回所有常量的关联数组，键是常量名，值是常量值 get_extension_funcs — 返回模块函数名称的数组 get_include_path — 获取当前的 include_path 配置选项 get_included_files — 返回被 include 和 require 文件名的 array get_loaded_extensions — 返回所有编译并加载模块名的 array get_magic_quotes_gpc — 获取当前 magic_quotes_gpc 的配置选项设置 get_magic_quotes_runtime — 获取当前 magic_quotes_runtime 配置选项的激活状态 get_required_files — 别名 get_included_files get_resources — Returns active resources getenv — 获取一个环境变量的值 getlastmod — 获取页面最后修改的时间 getmygid — 获取当前 PHP 脚本拥有者的 GID getmyinode — 获取当前脚本的索引节点（inode） getmypid — 获取 PHP 进程的 ID getmyuid — 获取 PHP 脚本所有者的 UID getopt — 从命令行参数列表中获取选项 getrusage — 获取当前资源使用状况 ini_alter — 别名 ini_set ini_get_all — 获取所有配置选项 ini_get — 获取一个配置选项的值 ini_restore — 恢复配置选项的值 ini_set — 为一个配置选项设置值 magic_quotes_runtime — 别名 set_magic_quotes_runtime main — 虚拟的main memory_get_peak_usage — 返回分配给 PHP 内存的峰值 memory_get_usage — 返回分配给 PHP 的内存量 php_ini_loaded_file — 取得已加载的 php.ini 文件的路径 php_ini_scanned_files — 返回从额外 ini 目录里解析的 .ini 文件列表 php_logo_guid — 获取 logo 的 guid php_sapi_name — 返回 web 服务器和 PHP 之间的接口类型 php_uname — 返回运行 PHP 的系统的有关信息 phpcredits — 打印 PHP 贡献者名单 phpinfo — 输出关于 PHP 配置的信息 phpversion — 获取当前的PHP版本 putenv — 设置环境变量的值 restore_include_path — 还原 include_path 配置选项的值 set_include_path — 设置 include_path 配置选项 set_magic_quotes_runtime — 设置当前 magic_quotes_runtime 配置选项的激活状态 set_time_limit — 设置脚本最大执行时间 sys_get_temp_dir — 返回用于临时文件的目录 version_compare — 对比两个「PHP 规范化」的版本数字字符串 zend_logo_guid — 获取 Zend guid zend_thread_id — 返回当前线程的唯一识别符 zend_version — 获取当前 Zend 引擎的版本 错误处理 debug_backtrace — 产生一条回溯跟踪(backtrace) debug_print_backtrace — 打印一条回溯。 error_clear_last — 清除最近一次错误 error_get_last — 获取最后发生的错误 error_log — 发送错误信息到某个地方 error_reporting — 设置应该报告何种 PHP 错误 restore_error_handler — 还原之前的错误处理函数 restore_exception_handler — 恢复之前定义过的异常处理函数。 set_error_handler — 设置用户自定义的错误处理函数 set_exception_handler — 设置用户自定义的异常处理函数 trigger_error — 产生一个用户级别的 error/warning/notice 信息 user_error — trigger_error 的别名 输出缓冲控制 flush — 刷新输出缓冲 ob_clean — 清空（擦掉）输出缓冲区 ob_end_clean — 清空（擦除）缓冲区并关闭输出缓冲 ob_end_flush — 冲刷出（送出）输出缓冲区内容并关闭缓冲 ob_flush — 冲刷出（送出）输出缓冲区中的内容 ob_get_clean — 得到当前缓冲区的内容并删除当前输出缓。 ob_get_contents — 返回输出缓冲区的内容 ob_get_flush — 刷出（送出）缓冲区内容，以字符串形式返回内容，并关闭输出缓冲区。 ob_get_length — 返回输出缓冲区内容的长度 ob_get_level — 返回输出缓冲机制的嵌套级别 ob_get_status — 得到所有输出缓冲区的状态 ob_gzhandler — 在ob_start中使用的用来压缩输出缓冲区中内容的回调函数。ob_start callback function to gzip output buffer ob_implicit_flush — 打开/关闭绝对刷送 ob_list_handlers — 列出所有使用中的输出处理程序。 ob_start — 打开输出控制缓冲 output_add_rewrite_var — 添加URL重写器的值（Add URL rewriter values） output_reset_rewrite_vars — 重设URL重写器的值（Reset URL rewriter values） 密码散列算法 password_get_info — 返回指定散列（hash）的相关信息 password_hash — 创建密码的散列（hash） password_needs_rehash — 检测散列值是否匹配指定的选项 password_verify — 验证密码是否和散列值匹配 Session session_abort — Discard session array changes and finish session session_cache_expire — 返回当前缓存的到期时间 session_cache_limiter — 读取/设置缓存限制器 session_commit — session_write_close 的别名 session_create_id — Create new session id session_decode — 解码会话数据 session_destroy — 销毁一个会话中的全部数据 session_encode — 将当前会话数据编码为一个字符串 session_gc — Perform session data garbage collection session_get_cookie_params — 获取会话 cookie 参数 session_id — 获取/设置当前会话 ID session_is_registered — 检查变量是否在会话中已经注册 session_module_name — 获取/设置会话模块名称 session_name — 读取/设置会话名称 session_regenerate_id — 使用新生成的会话 ID 更新现有会话 ID session_register_shutdown — 关闭会话 session_register — Register one or more global variables with the current session session_reset — Re-initialize session array with original values session_save_path — 读取/设置当前会话的保存路径 session_set_cookie_params — 设置会话 cookie 参数 session_set_save_handler — 设置用户自定义会话存储函数 session_start — 启动新会话或者重用现有会话 session_status — 返回当前会话状态 session_unregister — Unregister a global variable from the current session session_unset — 释放所有的会话变量 session_write_close — Write session data and end session JSON json_decode — 对 JSON 格式的字符串进行解码 json_encode — 对变量进行 JSON 编码 json_last_error_msg — Returns the error string of the last json_encode() or json_decode() call json_last_error — 返回最后发生的错误 Stream set_socket_blocking — 别名 stream_set_blocking stream_bucket_append — Append bucket to brigade stream_bucket_make_writeable — Return a bucket object from the brigade for operating on stream_bucket_new — Create a new bucket for use on the current stream stream_bucket_prepend — Prepend bucket to brigade stream_context_create — 创建资源流上下文 stream_context_get_default — Retrieve the default stream context stream_context_get_options — 获取资源流/数据包/上下文的参数 stream_context_get_params — Retrieves parameters from a context stream_context_set_default — Set the default stream context stream_context_set_option — 对资源流、数据包或者上下文设置参数 stream_context_set_params — Set parameters for a stream/wrapper/context stream_copy_to_stream — Copies data from one stream to another stream_filter_append — Attach a filter to a stream stream_filter_prepend — Attach a filter to a stream stream_filter_register — Register a user defined stream filter stream_filter_remove — 从资源流里移除某个过滤器 stream_get_contents — 读取资源流到一个字符串 stream_get_filters — 获取已注册的数据流过滤器列表 stream_get_line — 从资源流里读取一行直到给定的定界符 stream_get_meta_data — 从封装协议文件指针中取得报头／元数据 stream_get_transports — 获取已注册的套接字传输协议列表 stream_get_wrappers — 获取已注册的流类型 stream_is_local — Checks if a stream is a local stream stream_isatty — Check if a stream is a TTY stream_notification_callback — A callback function for the notification context parameter stream_register_wrapper — 别名 stream_wrapper_register stream_resolve_include_path — Resolve filename against the include path stream_set_blocking — 为资源流设置阻塞或者阻塞模式 stream_set_chunk_size — 设置资源流区块大小 stream_set_read_buffer — Set read file buffering on the given stream stream_set_timeout — Set timeout period on a stream stream_set_write_buffer — Sets write file buffering on the given stream stream_socket_accept — 接受由 stream_socket_server 创建的套接字连接 stream_socket_client — Open Internet or Unix domain socket connection stream_socket_enable_crypto — Turns encryption on/off on an already connected socket stream_socket_get_name — 获取本地或者远程的套接字名称 stream_socket_pair — 创建一对完全一样的网络套接字连接流 stream_socket_recvfrom — Receives data from a socket, connected or not stream_socket_sendto — Sends a message to a socket, whether it is connected or not stream_socket_server — Create an Internet or Unix domain server socket stream_socket_shutdown — Shutdown a full-duplex connection stream_supports_lock — Tells whether the stream supports locking stream_wrapper_register — 注册一个用 PHP 类实现的 URL 封装协议 stream_wrapper_restore — Restores a previously unregistered built-in wrapper stream_wrapper_unregister — Unregister a URL wrapper SPL class_implements — 返回指定的类实现的所有接口。 class_parents — 返回指定类的父类。 class_uses — Return the traits used by the given class iterator_apply — 为迭代器中每个元素调用一个用户自定义函数 iterator_count — 计算迭代器中元素的个数 iterator_to_array — 将迭代器中的元素拷贝到数组 spl_autoload_call — 尝试调用所有已注册的__autoload()函数来装载请求类 spl_autoload_extensions — 注册并返回spl_autoload函数使用的默认文件扩展名。 spl_autoload_functions — 返回所有已注册的__autoload()函数。 spl_autoload_register — 注册给定的函数作为 __autoload 的实现 spl_autoload_unregister — 注销已注册的__autoload()函数 spl_autoload — __autoload()函数的默认实现 spl_classes — 返回所有可用的SPL类 spl_object_hash — 返回指定对象的hash id spl_object_id — Return the integer object handle for given object BCMath bcadd — 2个任意精度数字的加法计算 bccomp — 比较两个任意精度的数字 bcdiv — 2个任意精度的数字除法计算 bcmod — 对一个任意精度数字取模 bcmul — 2个任意精度数字乘法计算 bcpow — 任意精度数字的乘方 bcpowmod — Raise an arbitrary precision number to another, reduced by a specified modulus bcscale — 设置所有bc数学函数的默认小数点保留位数 bcsqrt — 任意精度数字的二次方根 bcsub — 2个任意精度数字的减法 杂项 connection_aborted — 检查客户端是否已经断开 connection_status — 返回连接的状态位 constant — 返回一个常量的值 define — 定义一个常量 defined — 检查某个名称的常量是否存在 die — 等同于 exit eval — 把字符串作为PHP代码执行 exit — 输出一个消息并且退出当前脚本 get_browser — 获取浏览器具有的功能 __halt_compiler — 中断编译器的执行 highlight_file — 语法高亮一个文件 highlight_string — 字符串的语法高亮 hrtime — Get the system’s high resolution time ignore_user_abort — 设置客户端断开连接时是否中断脚本的执行 pack — 将数据打包成二进制字符串 php_check_syntax — 检查PHP的语法（并执行）指定的文件 php_strip_whitespace — 返回删除注释和空格后的PHP源码 sapi_windows_cp_conv — Convert string from one codepage to another sapi_windows_cp_get — Get process codepage sapi_windows_cp_is_utf8 — Indicates whether the codepage is UTF-8 compatible sapi_windows_cp_set — Set process codepage sapi_windows_vt100_support — Get or set VT100 support for the specified stream associated to an output buffer of a Windows console. show_source — 别名 highlight_file sleep — 延缓执行 sys_getloadavg — 获取系统的负载（load average） time_nanosleep — 延缓执行若干秒和纳秒 time_sleep_until — 使脚本睡眠到指定的时间为止。 uniqid — 生成一个唯一ID unpack — Unpack data from binary string usleep — 以指定的微秒数延迟执行]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题（猴子选大王）]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B%EF%BC%89PHP%E7%89%88%2F</url>
    <content type="text"><![CDATA[约瑟夫斯问题问题有时候也被描述成猴子选大王问题，题目如下。（最后会贴上约瑟夫问题的来历） 一群猴子排成一圈，按1,2,…,n依次编号。 然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。 要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。 用程序模拟该过程，代码如下： 1234567891011121314151617181920&lt;?php function monkeyKing($n, $m) &#123; $arr = range(1, $n); //构造一个数组 $i = 1; //从第一个开始循环 while (count($arr) &gt; 1) &#123; //如果总数大于1 if ($i % $m != 0) &#123; $arr[] = $arr[$i - 1]; //不被踢出则压入数组尾部 &#125; unset($arr[$i - 1]); //压入数组然后删除 $i++; //继续循环 &#125; return $arr[$i - 1]; //直到剩下最后一个大王 &#125; $king = monkeyKing(5, 3); 123456789101112131415function king($n, $m)&#123; $monkey = range(1, $n); //模拟建立一个连续数组 $i = 0; while (count($monkey) &gt; 1) &#123; $i += 1;//开始查数 $head = array_shift($monkey); //直接一个一个出列最前面的猴子 if ($i % $m != 0) &#123; array_push($monkey, $head); //如果没数到m或m的倍数,则把该猴放回尾部去. &#125; //否则就抛弃掉了 &#125; return $monkey[0];&#125;echo &apos;剩余&apos;, king(3, 4), &apos;号猴子&apos;; 下面是模拟的过程，对于不剔除的猴子，不断的加入数组尾部： 123456789101112131415161718 $n = 5 $m = 3 $arr = [1, 2, 3, 4, 5] $i $arr ---+------------------------ 1 x 2 3 4 5 1 2 x x 3 4 5 1 2&gt;3 x x x 4 5 1 2 4 x x x x 5 1 2 4 5 x x x x x 1 2 4 5&gt;6 x x x x x x 2 4 5 7 x x x x x x x 4 5 2 8 x x x x x x x x 5 2 4&gt;9 x x x x x x x x x 2 4 10 x x x x x x x x x x 4 2 11 x x x x x x x x x x x 2 4&gt;12 x x x x x x x x x x x x 4 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP使用redis]]></title>
    <url>%2F2019%2F04%2F13%2FPHP%E4%BD%BF%E7%94%A8redis%2F</url>
    <content type="text"><![CDATA[PHP使用redis连接到 redis 服务123456789101112&lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); //redis设置的密码 $redis-&gt;auth(&apos;xinglian272&apos;); //链接库 不行就是默认0 $redis-&gt;select(2); echo &quot;Connection to server successfully&quot;; //查看服务是否运行 echo &quot;Server is running: &quot; . $redis-&gt;ping();?&gt; String(字符串)set get123456789&lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); //设置 redis 字符串数据 $redis-&gt;set(&quot;tutorial-name&quot;, &quot;Redis tutorial&quot;); // 获取存储的数据并输出 $redis-&gt;get(&quot;tutorial-name&quot;);?&gt; setnx描述：如果在数据库中不存在该键，设置关键值参数参数：key value返回值：BOOL 成功返回：TRUE;失败返回：FALSE12345678910&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;); $redis-&gt;setnx(&apos;test&apos;,&quot;22222222&quot;); echo $redis-&gt;get(&apos;test&apos;); //结果：1111111111111 $redis-&gt;delete(&apos;test&apos;); $redis-&gt;setnx(&apos;test&apos;,&quot;22222222&quot;); echo $redis-&gt;get(&apos;test&apos;); //结果：22222222 ?&gt; incr(累加)描述：数字递增存储键值键.参数：key value：将被添加到键的值返回值：INT the new value 1234567&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;set(&apos;test&apos;,&quot;123&quot;); var_dump($redis-&gt;incr(&quot;test&quot;)); //结果：int(124) var_dump($redis-&gt;incr(&quot;test&quot;)); //结果：int(125) ?&gt; decr(递减)描述：数字递减存储键值。参数：key value：将被添加到键的值返回值：INT the new value 1234567&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;set(&apos;test&apos;,&quot;123&quot;); var_dump($redis-&gt;decr(&quot;test&quot;)); //结果：int(122) var_dump($redis-&gt;decr(&quot;test&quot;)); //结果：int(121) ?&gt; getMultiple描述：取得所有指定键的值。如果一个或多个键不存在，该数组中该键的值为假参数：其中包含键值的列表数组返回值：返回包含所有键的值的数组 12345678&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;set(&apos;test1&apos;,&quot;1&quot;); $redis-&gt;set(&apos;test2&apos;,&quot;2&quot;); $result = $redis-&gt;getMultiple(array(&apos;test1&apos;,&apos;test2&apos;)); print_r($result); //结果：Array ( [0] =&gt; 1 [1] =&gt; 2 ) ?&gt; List(列表)lpush rpush lrangelpush 由列表头部添加字符串值rpush 由列表尾部添加字符串值参数：key,value返回值：成功返回数组长度，失败false123456789101112131415&lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); //lpush 由列表头部添加字符串值 $redis-&gt;lpush(&quot;tutorial-list&quot;, &quot;Redis&quot;); $redis-&gt;lpush(&quot;tutorial-list&quot;, &quot;Mongodb&quot;); //rpush 由列表尾部添加字符串值 $redis-&gt;rpush(&quot;tutorial-list&quot;, &quot;Mysql&quot;); $redis-&gt;rpush(&quot;tutorial-list&quot;, &quot;Nosql&quot;); // 获取存储的数据并输出 $arList = $redis-&gt;lrange(&quot;tutorial-list&quot;, 0 ,5); print_r($arList);?&gt; lpop描述：返回和移除列表的第一个元素参数：key返回值：成功返回第一个元素的值 ，失败返回false 12345678910&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); $redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;); $redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;); var_dump($redis-&gt;lpop(&quot;test&quot;)); //结果：string(3) &quot;222&quot; ?&gt; lsize llen描述：返回的列表的长度。如果列表不存在或为空，该命令返回0。如果该键不是列表，该命令返回FALSE。参数：Key返回值：成功返回数组长度，失败false 12345678910&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); $redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;); $redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;); var_dump($redis-&gt;lsize(&quot;test&quot;)); //结果：int(4) ?&gt; lget描述：返回指定键存储在列表中指定的元素。 0第一个元素，1第二个… -1最后一个元素，-2的倒数第二…错误的索引或键不指向列表则返回FALSE。参数：key index返回值：成功返回指定元素的值，失败false 12345678910&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); $redis-&gt;rpush(&quot;test&quot;,&quot;333&quot;); $redis-&gt;rpush(&quot;test&quot;,&quot;444&quot;); var_dump($redis-&gt;lget(&quot;test&quot;,3)); //结果：string(3) &quot;444&quot; ?&gt; lset描述：为列表指定的索引赋新的值,若不存在该索引返回false.参数：key index value返回值：成功返回true,失败false 12345678910&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); var_dump($redis-&gt;lget(&quot;test&quot;,1)); //结果：string(3) &quot;111&quot; var_dump($redis-&gt;lset(&quot;test&quot;,1,&quot;333&quot;)); //结果：bool(true) var_dump($redis-&gt;lget(&quot;test&quot;,1)); //结果：string(3) &quot;333&quot; ?&gt; lgetrange描述：返回在该区域中的指定键列表中开始到结束存储的指定元素，lGetRange(key, start, end)。0第一个元素，1第二个元素… -1最后一个元素，-2的倒数第二…参数：key start end返回值：成功返回查找的值，失败false 12345678&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;); $redis-&gt;lpush(&quot;test&quot;,&quot;222&quot;); print_r($redis-&gt;lgetrange(&quot;test&quot;,0,-1)); //结果：Array ( [0] =&gt; 222 [1] =&gt; 111 ) ?&gt; lremove描述：从列表中从头部开始移除count个匹配的值。如果count为零，所有匹配的元素都被删除。如果count是负数，内容从尾部开始删除。参数：key count value返回值：成功返回删除的个数，失败false 123456789101112&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;lpush(&apos;test&apos;,&apos;a&apos;); $redis-&gt;lpush(&apos;test&apos;,&apos;b&apos;); $redis-&gt;lpush(&apos;test&apos;,&apos;c&apos;); $redis-&gt;rpush(&apos;test&apos;,&apos;a&apos;); print_r($redis-&gt;lgetrange(&apos;test&apos;, 0, -1)); //结果：Array ( [0] =&gt; c [1] =&gt; b [2] =&gt; a [3] =&gt; a ) var_dump($redis-&gt;lremove(&apos;test&apos;,&apos;a&apos;,2)); //结果：int(2) print_r($redis-&gt;lgetrange(&apos;test&apos;, 0, -1)); //结果：Array ( [0] =&gt; c [1] =&gt; b ) ?&gt; List(集合)sadd描述：为一个Key添加一个值。如果这个值已经在这个Key中，则返回FALSE。参数：key value返回值：成功返回true,失败false 12345678&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); var_dump($redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;)); //结果：bool(true) var_dump($redis-&gt;sadd(&apos;test&apos;,&apos;333&apos;)); //结果：bool(true) print_r($redis-&gt;sort(&apos;test&apos;)); //结果：Array ( [0] =&gt; 111 [1] =&gt; 333 ) ?&gt; sremove描述：删除Key中指定的value值参数：key member返回值：true or false 123456789&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); $redis-&gt;sadd(&apos;test&apos;,&apos;333&apos;); $redis-&gt;sremove(&apos;test&apos;,&apos;111&apos;); print_r($redis-&gt;sort(&apos;test&apos;)); //结果：Array ( [0] =&gt; 333 ) ?&gt; smove描述：将Key1中的value移动到Key2中参数：srcKey dstKey member返回值：true or false 123456789101112&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;delete(&apos;test1&apos;); $redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); $redis-&gt;sadd(&apos;test&apos;,&apos;333&apos;); $redis-&gt;sadd(&apos;test1&apos;,&apos;222&apos;); $redis-&gt;sadd(&apos;test1&apos;,&apos;444&apos;); $redis-&gt;smove(&apos;test&apos;,&quot;test1&quot;,&apos;111&apos;); print_r($redis-&gt;sort(&apos;test1&apos;)); //结果：Array ( [0] =&gt; 111 [1] =&gt; 222 [2] =&gt; 444 ) ?&gt; scontains描述：检查集合中是否存在指定的值。参数：key value返回值：true or false 123456789&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); $redis-&gt;sadd(&apos;test&apos;,&apos;112&apos;); $redis-&gt;sadd(&apos;test&apos;,&apos;113&apos;); var_dump($redis-&gt;scontains(&apos;test&apos;, &apos;111&apos;)); //结果：bool(true) ?&gt; ssize描述：返回集合中存储值的数量参数：key返回值：成功返回数组个数，失败0 12345678&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;); $redis-&gt;sadd(&apos;test&apos;,&apos;112&apos;); echo $redis-&gt;ssize(&apos;test&apos;); //结果：2 ?&gt; spop描述：随机移除并返回key中的一个值参数：key返回值：成功返回删除的值，失败false 123456789&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); var_dump($redis-&gt;spop(&quot;test&quot;)); //结果：string(3) &quot;333&quot; ?&gt; sinter描述：返回一个所有指定键的交集。如果只指定一个键，那么这个命令生成这个集合的成员。如果不存在某个键，则返回FALSE。参数：key1, key2, keyN返回值：成功返回数组交集，失败false 1234567891011&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); var_dump($redis-&gt;sinter(&quot;test&quot;,&quot;test1&quot;)); //结果：array(1) &#123; [0]=&gt; string(3) &quot;111&quot; &#125; ?&gt; sinterstore描述：执行sInter命令并把结果储存到新建的变量中。参数：Key: dstkey, the key to store the diff into.Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.返回值：成功返回，交集的个数，失败false 123456789101112&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); var_dump($redis-&gt;sinterstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;)); //结果：int(1) var_dump($redis-&gt;smembers(&apos;new&apos;)); //结果:array(1) &#123; [0]=&gt; string(3) &quot;111&quot; &#125; ?&gt; sunion描述：返回一个所有指定键的并集参数：Keys: key1, key2, … , keyN返回值：成功返回合并后的集，失败false 1234567891011&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); print_r($redis-&gt;sunion(&quot;test&quot;,&quot;test1&quot;)); //结果：Array ( [0] =&gt; 111 [1] =&gt; 222 [2] =&gt; 333 [3] =&gt; 444 ) ?&gt; sunionstore描述：执行sunion命令并把结果储存到新建的变量中。参数：Key: dstkey, the key to store the diff into.Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.返回值：成功返回，交集的个数，失败false 123456789101112&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); var_dump($redis-&gt;sinterstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;)); //结果：int(4) print_r($redis-&gt;smembers(&apos;new&apos;)); //结果:Array ( [0] =&gt; 111 [1] =&gt; 222 [2] =&gt; 333 [3] =&gt; 444 ) ?&gt; sdiff描述：返回第一个集合中存在并在其他所有集合中不存在的结果参数：Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis.返回值：成功返回数组，失败false 1234567891011&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); print_r($redis-&gt;sdiff(&quot;test&quot;,&quot;test1&quot;)); //结果：Array ( [0] =&gt; 222 [1] =&gt; 333 ) ?&gt; sdiffstore描述：执行sdiff命令并把结果储存到新建的变量中。参数：Key: dstkey, the key to store the diff into.Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis返回值：成功返回数字，失败false 123456789101112&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;333&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test1&quot;,&quot;444&quot;); var_dump($redis-&gt;sdiffstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;)); //结果：int(2) print_r($redis-&gt;smembers(&apos;new&apos;)); //结果:Array ( [0] =&gt; 222 [1] =&gt; 333 ) ?&gt; smembers, sgetmembers描述：返回集合的内容参数：Key: key返回值：An array of elements, the contents of the set. 12345678&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;delete(&apos;test&apos;); $redis-&gt;sadd(&quot;test&quot;,&quot;111&quot;); $redis-&gt;sadd(&quot;test&quot;,&quot;222&quot;); print_r($redis-&gt;smembers(&apos;test&apos;)); //结果:Array ( [0] =&gt; 111 [1] =&gt; 222 ) ?&gt; delete(删除)参数：一个键，或不确定数目的参数，每一个关键的数组：key1 key2 key3 … keyN返回值：删除的项数12345678&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;); echo $redis-&gt;get(&apos;test&apos;); //结果：1111111111111 $redis-&gt;delete(&apos;test&apos;); var_dump($redis-&gt;get(&apos;test&apos;)); //结果：bool(false) ?&gt; exists参数key返回值：Bool 成功返回：TRUE;失败返回：FALSE描述：验证指定的键是否存在 123456&lt;?php $redis = new redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); $redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;); var_dump($redis-&gt;exists(&apos;test&apos;)); //结果：bool(true) ?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门]]></title>
    <url>%2F2019%2F03%2F27%2Fdocker%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Docker安装Mac：https://docs.docker.com/docke...Windows:https://docs.docker.com/docke...linux:官网有不同版本的安装的教程ubuntu:https://docs.docker.com/engin... Docker三个基本概念下面这张图非常的经典，很形象地展示了，什么是容器，什么是镜像，什么是仓库，以及三者之间的联系。 接下来我们来解释一下这张图。现在我们要造一间厨房，在造之前我们首先要干的一件事，就是先列举出我们造厨房需要的东西。我们可能需要一个通了水电煤的房子以及一些必需的厨房用具诸如锅碗瓢勺、煤气灶、冰箱、水槽等等这些东西。现在我们知道需要了什么东西之后，我们就去找这些东西。首先我们先去京东购买一些厨房用具，这些用具就好比我们的Docker镜像，我们厨房的用具到了之后得找个地方把它们放在，不可能随处丢吧，不然后面用的时候就找不到它了，那么我们Docker镜像也是这样，需要一个Docker仓库去存储这些镜像。现在我们有了这些厨房用具之后就可以做饭了吗？答案当然是不能，没水没电没火啊！这时候我们得把厨房用具给装到一个通了水电煤的房子才行，那么Docker镜像也是这样，单纯的Docker镜像是不能用的，它得装到Docker容器中通了水电煤才能使用。等我们装好了厨房用具之后我们就可以开始做饭，那么我们的Docker镜像装到Docker容器之后，我们应用就可以跑起来了。 Docker常用命令1.杀死所有正在运行的容器1docker kill $(docker ps -a -q) 2.删除所有已经停止的容器1docker rm $(docker ps -a -q) 3.删除所有镜像1docker rmi $(docker images -q) 4.关闭容器1docker stop CONTAINER ID或者NAMES 5.重新启动关闭的容器1docker start CONTAINER ID或者NAMES 6.移除本地容器1docker rm CONTAINER ID或者NAMES 7.查看本地容器12docker ps //查看正在运行的容器docker ps -a //查看所有容器 8.查看本地镜像1docker images 9.创建镜像1docker build -t name:tag Dockerfile路径 10.修改本地镜像标记12docker tag IMAGE ID name:tag docker rmi name:tag 11.删除本地镜像1docker rmi name:tag或者IMAGE ID 12.进入容器1docker exec -it IMAGE ID或者NAMES /bin/bash 13.获取镜像中心的镜像1docker pull name:tag 14.获取容器的端口映射配置1docker port CONTAINER ID或者NAMES]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows上利用docker搭建lnmp开发环境]]></title>
    <url>%2F2019%2F03%2F27%2Fwindows%E4%B8%8A%E5%88%A9%E7%94%A8docker%E6%90%AD%E5%BB%BAlnmp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装docker到docker官网进行安装书籍:Docker技术入门与实战 开启Hyper-V打开控制面板 - 程序和功能 - 启用或关闭Windows功能，勾选Hyper-V，然后点击确定即可，如图： 下载windwos版本docker安装包 地址 修改docker 镜像仓库安装好后登陆docker（没有账号的请到官网进行注册） 使用git快速获取lnmp切换到你准备安装dnmp的目录下 123$ git clone https://github.com/shmilylbelva/dnmp.git$ cd dnmp$ docker-compose up 完成以后可以在浏览器中访问localhost，出现界面代表ok 站点部署c:\Windows\System32\Drivers\etc\hosts 本文有默认加了两个站点：www.site1.com（同localhost）和www.site2.com。要在本地访问这两个域名，需要修改你的hosts文件，添加以下两行：127.0.0.1 www.site1.com127.0.0.1 www.site2.com其中，www.site2.com为支持SSL/https和HTTP/2的示例站点。因为站点2的SSL采用自签名方式，所以浏览器有安全提示，继续访问就可以了，自己的站点用第三方SSL认证证书替换即可。如果只用到站点1，把站点2相关的目录和配置文件删除：./conf/nginx/conf.d/certs/site2/./conf/nginx/conf.d/site2.conf./www/site2/重启容器内的Nginx生效：docker exec -it dlnmp_nginx nginx -s reload dnmp目录结构12345678910111213141516171819202122232425.├── conf 配置目录│ ├── conf.d 站点配置文件目录│ │ ├── certs SSL认证文件、密钥和加密文件目录│ │ │ └── site2 站点2的认证文件目录│ │ ├── site1.conf 站点1 Nginx配置文件│ │ └── site2.conf 站点2 Nginx配置文件 │ ├── my.cnf MySQL配置文件 │ ├── nginx.conf Nginx通用配置文件│ ├── php-fpm.d PHP-FPM配置目录│ │ └── www.conf PHP-FPM配置文件│ ├── php.ini PHP配置文件├── docker-compose.yml 默认容器启动配置文件├── docker-compose54.yml php5.4容器启动配置文件├── docker-compose56.yml php5.6容器启动配置文件├── log 日志目录│ ├── mysql.slow.log MySQL日志│ ├── nginx.error.log Nginx日志│ ├── nginx.site1.error.log │ ├── nginx.site2.error.log ├── mysql MySQL数据文件目录├── php PHP版本目录└── www 站点根目录 ├── site1 站点1根目录 └── site2 站点2根目录 MYSQL说明在docker-compose.yml文件中，我们指定了MySQL数据库root用户的密码为123456。所以，我们就可以在主机中通过： 12345$ mysql -h 127.0.0.1 -u root -p #linux中#在mac中需要先切换到mysql容器$ docker container ls #列出容器列表$ docker exec -it 775c7c9ee1e1 /bin/bash #其中的容器id不用输入完整的mysql容器id,一般3位就能区分。$ mysql -h 127.0.0.1 -uroot -p 输入密码，就可以进入MySQL命令行。 说明：这里MySQL的连接主机不能用localhost，因为MySQL客户端默认使用unix socket方式连接，应该直接用本地IP。在PHP代码中的使用方式与在主机中使用稍有不同，如下：$pdo = new PDO(‘mysql:host=mysql;dbname=site1’, ‘root’, ‘123456’);其中，host的值就是在docker-compose.yml里面指定的MySQL容器的名称。这是因为PHP代码是在FPM容器中，FPM容器启动时会自动在/etc/hosts中加上：172.17.0.2 mysql 11e55f91c4c3 dnmp_mysql就是说，mysql自动指向了MySQL容器动态生成的IP。注意，这里用php进行mysql连接测试会失败（在docker-compose up的时候注意到存在mbind:Operation not permitted 这个提示） ，所以还需要处理上述问题。进入刚刚的mysql终端,内容大致如下。host为 % 表示不限制ip localhost表示本机使用 plugin非mysql_native_password 则需要修改密码 12345678910mysql&gt; select host,user,plugin,authentication_string from mysql.user; +-----------+------------------+-----------------------+------------------------------------------------------------------------+ | host | user | plugin | authentication_string | +-----------+------------------+-----------------------+------------------------------------------------------------------------+ | % | root | caching_sha2_password | $A$005$^]RQB&#125;j~t! .#v)3.UogPRFu8VJA5/GKEbK5edEQlMT5sHw2n72zYJNlIbo3 | | localhost | mysql.infoschema | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | | localhost | mysql.session | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | | localhost | mysql.sys | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | | localhost | root | caching_sha2_password | $A$005$Y6&amp;q!59^Fmh)@-6TG58J3F5+3I/HI9L|JCadNG+-+d6W+1D_UFW+7MRD7F3 | +-----------+------------------+-----------------------+------------------------------------------------------------------------+ 依次进行如下操作 1234#更新一下用户的密码 root用户密码为newpassword mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;FLUSH PRIVILEGES; mysql连接问题解决。 修改docker-compose.yml如果容器已经生成，回头再编辑docker-compose.yml，用docker-compose up命令会直接启动原来的容器，修改的内容不会体现在启动的容器里。所以，要使修改的docker-compose.yml生效，需要以下4步： 1234$ docker stop dnmp_nginx # 第一步：停止容器$ docker rm dnmp_nginx # 第二步：删除容器# !!第三步：重启Docker服务!!$ docker-compose up -d --no-deps --build mysql # 第四步：重新启动容器 其中最后一条命令参数作用：/-d：后台执行–no-deps：不启动link的容器–build：启动容器前先构建镜像 使用RedisRedis使用和MySQL类似。不过需要注意的是在./php/php72中的Dockerfile末尾的 1234567891011#源码安装方式#php7 can installENV PHPREDIS_VERSION 4.0.0RUN curl -L -o /tmp/redis.tar.gz https://github.com/phpredis/phpredis/archive/$PHPREDIS_VERSION.tar.gz \ &amp;&amp; tar xfz /tmp/redis.tar.gz \ &amp;&amp; rm -r /tmp/redis.tar.gz \ &amp;&amp; mkdir -p /usr/src/php/ext \ &amp;&amp; mv phpredis-$PHPREDIS_VERSION /usr/src/php/ext/redis \ &amp;&amp; docker-php-ext-install redis \ &amp;&amp; rm -rf /usr/src/php 如果是php5.X那么这里应该是这样的（需要自己添加到对应的Dockerfile中，然后再docker-compose up） 123456789101112#PECL安装方式#php5 can install#添加扩展 redis pecl方式RUN apk add --no-cache --update libmemcached-libs zlibRUN set -xe \ &amp;&amp; apk add --no-cache --update --virtual .phpize-deps $PHPIZE_DEPS \ &amp;&amp; pecl install -o -f redis \ &amp;&amp; echo &quot;extension=redis.so&quot; &gt; /usr/local/etc/php/conf.d/redis.ini &amp;&amp; rm -rf /usr/share/php \ &amp;&amp; rm -rf /tmp/* \ &amp;&amp; apk del .phpize-deps 在主机和容器内部都通过地址127.0.0.1，端口6379访问。 PHP则是跨容器访问，host参数用redis（links指定的名称），端口用6379。修改site2的index.php文件内容如下 123456&lt;?php $redis = new Redis(); $redis-&gt;connect(&apos;192.168.1.11&apos;,6379);//修改成自己的ip $redis-&gt;set(&apos;name&apos;,&apos;青波&apos;); echo $redis-&gt;get(&apos;name&apos;); //检测是否连接成功 浏览器访问www.site2.com,出现‘青波’即代表redis扩展正常。 作者：回眸淡然笑链接：https://www.jianshu.com/p/31c09a3e0d5d来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写文章（基于 Markdown）]]></title>
    <url>%2F2019%2F03%2F23%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[创建文章在站点文件夹中打开 git bash，输入如下命令创建文章，其中 title 为文章的标题1$ hexo new "title" 当输入命令后，就会在 source/_post 文件夹下创建一个文件，命名为：title.md这个文件就是将要发布到网站上的原始文件，用于记录文章内容下面，我们将要在这个文件中写下我们的第一篇博客 编写文章（基于 Markdown）Markdown 简介但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？1Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式 基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言 Markdown 语法在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览这里附上 Typora 的下载地址：https://www.typora.io/ 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 粗体、斜体、删除线和下划线1234*斜体***粗体*****加粗斜体***~~删除线~~ 引用块1&gt; 文字引用 公式块123$$数学公式$$ 分割线12345方法一：---方法二：+++方法三：*** 列表12345671. 有序列表项* 无序列表项+ 无序列表项- 无序列表项 表格1234表头1|表头2-|-|-内容11|内容12内容21|内容22 超链接12345方法一：[链接文字](链接地址 "链接描述")例如：[示例链接](https://www.example.com/ "示例链接")方法二：&lt;链接地址&gt;例如：&lt;https://www.example.com/&gt; 图片12![图片文字](图片地址 "图片描述")例如：![示例图片](https://www.example.com/example.PNG "示例图片") 说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置将 站点配置文件 中的 post_asset_folder 选项的值设置为 true在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 添加图片(注意有感叹号!前面) Hexo NexT 内置标签「标签」(Tag Plugin) 是 Hexo 提供的一种快速生成特定内容的方式。例如，在标准 Markdown 语法中，我们无法指定图片的大小。这种情景，我们即可使用标签来解决。 Hexo 内置来许多标签来帮助写作者可以更快的书写，完整的标签列表 可以参考 Hexo 官网。 另外，Hexo 也开放来接口给主题，使主题有可能提供给写作者更简便的写作方法。以下标签便是 NexT 主题当前提供的标签。 文本居中的引用此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。例如作为文章开篇引用 或者 结束语之前的总结引用。 使用方式 HTML方式：使用这种方式时，给 img 添加属性 class=”blockquote-center” 即可。 标签方式：使用 centerquote 或者 简写 cq。 1此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式。 123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 突破容器宽度限制的图片当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片,图片的扩大与容器的偏差从视觉上提升图片的吸引力。 此标签有两种调用方式（详细参看底下示例）： 使用方式 HTML方式：使用这种方式时，为 img 添加属性 class=”full-image”即可。 标签方式：使用 fullimage 或者 简写 fi， 并传递图片地址、 alt 和 title 属性即可。 属性之间以逗号分隔。 12此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式。如果要在图片下显示图片的标题，请使用 标签方式 并给定 title 属性。 123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;full-image&quot; 是必须的 --&gt;&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% fullimage /image-url, alt, title %&#125;&lt;!-- 别名 --&gt;&#123;% fi /image-url, alt, title %&#125; Bootstrap Callout 由 ivan-nginx 贡献这些样式出现在 Bootstrap 的官方文档中。 使用方式1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default primary success info warning danger]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 语言入门笔记]]></title>
    <url>%2F2019%2F03%2F23%2FGo%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[工作需要入手了 Go 语言，开发使用的是 Gin Web Framework。 入手后发现语法和 PHP/Python/JavaScript 之流还是有很大区别的，下面对学习资料及入门笔记做简单整理。 简介 Go（又称 Golang ），由 Google 开发 是一种 静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言 语法接近 C 语言，但对于变量的声明有所不同 安装安装 直接前往 官网 下载 .pkg 完成安装。go中文网 一般去中文网下载 workspace用于放置一个 go 程序员的所有 go 代码和依赖。 目录结构 src：go源码文件 pkg：package object（编译出的二进制文件） bin：可执行文件（编译出的二进制文件） GOPATHworkspace 的路径，默认为 $HOME/go。 设置直接安装 .pkg 文件未设置 GOPATH，需要手动设置一下：1export GOPATH=$HOME/go 加入环境变量： 1export PATH=$PATH:$(go env GOPATH)/bin 编辑器折腾了好久别的编辑器还是用jetbrains 的 GoLand 舒服功能齐全 Hello, World入口程序入口为：main.main。 12345package mainfunc main() &#123; ...&#125; hello.go创建新项目：/Users/jjy/go/src/exampleProject，新建文件 hello.go： 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, world!&quot;)&#125; 编译在 /Users/jjy/go/src/exampleProject 下执行 go install，之后会在 $GOPATH/bin 目录下生成编译后的二进制程序。 执行12▶ /Users/jjy/go/bin/exampleProjectHello, world! 一些特性 函数多返回值 并发编程 错误处理 学习资料 官方文档 Go语言学习 - cyent笔记 awesome-go Go 入门指南]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序是怎么跑起来的]]></title>
    <url>%2F2019%2F01%2F04%2F%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%2F</url>
    <content type="text"><![CDATA[对程序员来说CPU是什么？热身1.程序是什么？2.程序是由什么组成的？3.什么是机器语言？4.正在运行的程序存储在什么位置？5.什么是内存地址？6.计算机的构成原件中，负责程序的解释和运行的是哪个？ 我的第一次回答1.计算机运行的命令2.由指令和数据组成3.计算机可以直接识别的语言4.内存5.一个位置6.CPU 答案 1.指示计算机每一步动作的一组指令2.指令和数据3.CPU可以直接识别并使用的语言4.内存5.内存中，用来表示命令和数据存储位置的数值6.CPU]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十年学会编程]]></title>
    <url>%2F2019%2F01%2F02%2F%E5%8D%81%E5%B9%B4%E5%AD%A6%E4%BC%9A%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[十年学会编程 Teach Yourself Programming in Ten YearsPeter NorviGWhy is everyone in such a rush？为何每个人都急于求成?Walk into any bookstore, and you’ll see how to Teach Yourself Java in 24 Hours alongside endless variations offering to teach C, SQL, Ruby, Algorithms, and so on in a few days or hours. The Amazon advanced search for [title: teach, yourself, hours, since: 2000 and found 512 such books. Of the top ten, nine are programming books (the other is about bookkeeping). Similar results come from replacing “teach yourself” with “learn” or “hours” with “days.” 随便走进一家书店，都会看到类似《24小时学会Java》这样的书，旁边摆着的是大量诸如在几天，几小时之内学会C语言，SQL，Ruby以及算法这样的书。如果使用Amazon上的高级搜索，使用title: teach, yourself, hours, since: 2000这个关键字来搜索，将会返回512本书。最靠前的10本书中，有9本是编程的书（唯一的例外是一本记账的书）。如果把关键字”teach yourself”替换成”learn”，或者将”hours”替换成”days”，返回的结果大同小异。 The conclusion is that either people are in a big rush to learn about programming, or that programming is somehow fabulously easier to learn than anything else. Felleisen et al. give a nod to this trend in their book How to Design Programs, when they say “Bad programming is easy. Idiots can learn it in 21 days, even if they are dummies.” The Abtruse Goose comic also had their take. 很明显，人们在学习编程的时候喜欢大跃进，或者认为编程比起其它事情来，是小菜一碟的事。Felleisen在他的书《How to Design Program》里说：“编烂程一点也不难。傻瓜也可以在21天内学会，即使他们是傻逼。”在搞笑漫画网站Abtruse Goose也在这个漫画中表达了同样的看法。 Let’s analyze what a title like Teach Yourself C++ in 24 Hours could mean: 我们来看看类似《24小时自学C++》这种标题党，到底说的什么鬼东西： Teach Yourself: In 24 hours you won’t have time to write several significant programs, and learn from your successes and failures with them. You won’t have time to work with an experienced programmer and understand what it is like to live in a C++ environment. In short, you won’t have time to learn much. So the book can only be talking about a superficial familiarity, not a deep understanding. As Alexander Pope said, a little learning is a dangerous thing.自学: 24小时之内，你没有时间写几个有意义的程序，也就无法从成功或失败中学到经验。24小时之内，你没有时间和一个有经验的程序员合作交流，也就无从理解使用C++编程的真实场景。简单来说，时间太短，你啥也学不到。因此，有这种干货标题的速成书，只是让你走马观花的瞧一下，绝非深入的理解。18世纪的英国诗人亚历山大·蒲柏[……1]曾说过：“一知半解”是一件危险的事情。[……1]：这个哥哥还给牛顿写了最出名的墓志铭之一：“自然和自然律隐没在黑暗中；上帝说，让牛顿去吧！遂一片光明。”C++: In 24 hours you might be able to learn some of the syntax of C++ (if you already know another language), but you couldn’t learn much about how to use the language. In short, if you were, say, a Basic programmer, you could learn to write programs in the style of Basic using C++ syntax, but you couldn’t learn what C++ is actually good (and bad) for. So what’s the point? Alan Perlis once said: “A language that doesn’t affect the way you think about programming, is not worth knowing”. One possible point is that you have to learn a tiny bit of C++ (or more likely, something like JavaScript or Processing) because you need to interface with an existing tool to accomplish a specific task. But then you’re not learning how to program; you’re learning to accomplish that task.C++: (如果你有一定的编程基础)，在24小时之内，能学会一些C++的语法，但是，仅此而已了。如果你以前是个Basic语言的程序员，你可以写一些语法是C++，但是风格是Basic的程序，但是，24小时之内，C++语言的精华或糟粕，你都学不到。重点是什么？(首界图灵奖得主)Alan Perlis曾说过：“不能影响你编程思维方式的语言，是不值得学习的。”一个更加可能的场景是，在工作中，你不得不学习C++（或者JavaScript，Processing之类）的一小部分，来调用一些原有的接口，完成某个特定的任务。这种情况下，表面上说是在学习如何编程，其实只是在应付一下手上的活。in 24 Hours: Unfortunately, this is not enough, as the next section shows.24小时内:很不幸，24小时太少了，原因下面告诉你。 Teach Yourself Programming in Ten Years十年学会编程Researchers (Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)) have shown it takes about ten years to develop expertise in any of a wide variety of areas, including chess playing, music composition, telegraph operation, painting, piano playing, swimming, tennis, and research in neuropsychology and topology. The key is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again. There appear to be no real shortcuts: even Mozart, who was a musical prodigy at age 4, took 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the scene with a string of #1 hits and an appearance on the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critical success, Sgt. Peppers, was released in 1967. 研究表明，想在任何领域成为专家，大概需要10年的时间，这些领域包括下棋，作曲，发电报，弹钢琴，游泳，打网球，研究神经心理学和拓扑学。关键在于有针对性的训练，而不是漫无目的重复，训练的内容要刚好超过你现有的水平，练习以后要分析你的表现，改正发现的错误，然后重复，再重复。没有什么捷径可走，即使是Mozart，一个4岁就能弹琴的音乐天才，也是用了13年的时间，才真正的写出世界级的音乐作品。在流行音乐上，Beatles好像是在1964年访美期间一夜成名的。实际上，他们从1957年就已经开始在利物浦和汉堡的小酒馆里唱歌了，他们组建乐队的时间就更早了，他们第一张取得巨大成功的专辑《佩帕军士》，是在1967年发行的。 Malcolm Gladwell has popularized the idea, although he concentrates on 10,000 hours, not 10 years. Henri Cartier-Bresson (1908-2004) had another metric: “Your first 10,000 photographs are your worst.” (He didn’t anticipate that with digital cameras, some people can reach that mark in a week.) True expertise may take a lifetime: Samuel Johnson (1709-1784) said “Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price.” And Chaucer (1340-1400) complained “the lyf so short, the craft so long to lerne.” Hippocrates (c. 400BC) is known for the excerpt “ars longa, vita brevis”, which is part of the longer quotation “Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”, which in English renders as “Life is short, [the] craft long, opportunity fleeting, experiment treacherous, judgment difficult.” Of course, no single number can be the final answer: it doesn’t seem reasonable to assume that all skills (e.g., programming, chess playing, checkers playing, and music playing) could all require exactly the same amount of time to master, nor that all people will take exactly the same amount of time. As Prof. K. Anders Ericsson puts it, “In most domains it’s remarkable how much time even the most talented individuals need in order to reach the highest levels of performance. The 10,000 hour number just gives you a sense that we’re talking years of 10 to 20 hours a week which those who some people would argue are the most innately talented individuals still need to get to the highest level.” 马尔科姆·格拉德威尔让这个理论广为人知，虽然他说的是另一个说法，10，000个小时而不是10年(这本书有中文翻译版异类 : 不一样的成功启示录)。法国现实主义摄影大师亨利·卡蒂埃-布列松有另外一个标准，他说你的前10,000张照片是你最差的。(当然，这个摄影大师没有意识到数码相机的出现，很多人能在一周内就可以拍10,000张照片)真正的大师要用一生来完成，英国作家，文学评论家和诗人塞缪尔·约翰逊说过：“在任何领域取得卓越的成就都要用一生的努力，不要妄想可以投机取巧。”英国的诗人乔叟也曾经说过：”吾生也有涯 而知也无涯。”同样，公元前400年的希波克拉底也表达过类似的意思，他也认为艺术没有止境，生命却有尽头。他说的这句话有个更长的版本，翻译成英语的意思是：“生命有尽头，艺术无止境，机遇转瞬即逝，练功走火入魔，决定优柔寡断。”当然，不会有一个确定的答案告诉你需要多长时间，毕竟，假设掌握所有的技能(比如编程，下棋，跳棋和音乐)需要相同的时间也不合适，不同的人也会用不同的时间。K.Anders Ericsson教授说过：“值得注意的是，在大多数领域，即使你是个天才，要达到专家级别的高水平仍然需要时间。10，000个小时只是给你一个概念，一个天才，如果每周练习10到20个小时的时间，仍然需要数年时间才能达到专家级别的水平。” So You Want to be a Programmer所以你想成为一个程序员Here’s my recipe for programming success: 这是我编程成功的秘笈: Get interested in programming, and do some because it is fun. Make sure that it keeps being enough fun so that you will be willing to put in your ten years/10,000 hours. 要对编程感兴趣，要从中能获得快乐。保证编程足够有趣，这样才能让你花10年的时间或者10，000个小时在上面也不觉得枯燥无味。 Program. The best kind of learning is learning by doing. To put it more technically, “the maximal level of performance for individuals in a given domain is not attained automatically as a function of extended experience, but the level of performance can be increased even by highly experienced individuals as a result of deliberate efforts to improve.” (p. 366) and “the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors.” (p. 20-21) The book Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life is an interesting reference for this viewpoint. 动手编程。最好的学习方法是边学边做。常言道：“人的最高功力并不能通过做一天和尚撞一天钟这样的重复经验获得，但是，最高的功力可以通过有针对性的日复一日年复一年的训练来获得。”并且，“最有效果的学习需要有针对性的任务，这些任务的难度还要因人而异，并且有合理的反馈渠道，并能够根据这些反馈作出相应的改进。”这些观点引用自《Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life》这本书里。 Talk with other programmers; read other programs. This is more important than any book or training course. 和其他的程序员交流；阅读别人的代码。这比看书或者参加培训课程要重要。 If you want, put in four years at a college (or more at a graduate school). This will give you access to some jobs that require credentials, and it will give you a deeper understanding of the field, but if you don’t enjoy school, you can (with some dedication) get similar experience on your own or on the job. In any case, book learning alone won’t be enough. “Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter” says Eric Raymond, author of The New Hacker’s Dictionary. One of the best programmers I ever hired had only a High School degree; he’s produced a lot of greatsoftware, has his own news group, and made enough in stock options to buy his own nightclub. 如果你愿意，在大学里花上四年时间（或者再读个研）。这能让你获得一些工作机会，也能让你在这个领域有更深入的了解。但是，如果你一上学就头痛，直接去工作也能获得相同的经验。无论是什么情况，读死书肯定是不行的。计算机科学不会让你成为编程专家，就像学习画笔和颜料不可能让你成为画家一样。这是Eric Raymond说的，他是New Hacker’s Dictionary字典的作者。我雇佣过的最好的程序员是个高中毕业的学生，他创造了伟大的软件，Mozilla，他拥有自己的新闻组，赚到了足够多的钱买了自己的酒吧。 Work on projects with other programmers. Be the best programmer on some projects; be the worst on some others. When you’re the best, you get to test your abilities to lead a project, and to inspire others with your vision. When you’re the worst, you learn what the masters do, and you learn what they don’t like to do (because they make you do it for them). 和其他的程序员一起参与一些项目。在一些项目中成为最出色的程序员；在另一些项目中当最差劲的程序员。在当最出色的程序员的时候，要测试你领导项目的能力，用你的视野来启发别人。如果你是项目中最差的那个，要学习牛人们在做什么，如果他们不喜欢做的，你要拿来做。 Work on projects after other programmers. Understand a program written by someone else. See what it takes to understand and fix it when the original programmers are not around. Think about how to design your programs to make it easier for those who will maintain them after you. 接手并推进别人的项目。理解其他人写的代码。如果别人有没有考虑到的问题，你能理解并修复这些问题。思考并设计你的软件，让这些软件容易被他人维护。 Learn at least a half dozen programming languages. Include one language that emphasizes class abstractions (like Java or C++), one that emphasizes functional abstraction (like Lisp or ML or Haskell), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), and one that emphasizes parallelism (like Clojure or Go). 学习至少6种(我不太清楚英语中的half dozen是什么意思，是虚指还是就是6种)编程语言。这6种语言中，包括一种支持抽象类的(例如Java或者C++)，一种支持函数的(Lisp, ML或者Haskell)，一种支持语义抽象的(Lisp)，一种支持声明规范的(Prolog或者C++模板)，还有一种支持并发的(Clojure或Go)。 Remember that there is a “computer“ in “computer science”. Know how long it takes your computer to execute an instruction, fetch a word from memory (with and without a cache miss), read consecutive words from disk, and seek to a new location on disk. (Answers here.) 记住，在“计算机科学”中在“计算机”这个词语。理解执行一条指令要花多长时间，从内存中取一个字（要考虑缓存有没有命中的情况）要多久，从硬盘中连续读字节要多久，在硬盘中寻址定位要多久？ Get involved in a language standardization effort. It could be the ANSI C++ committee, or it could be deciding if your local coding style will have 2 or 4 space indentation levels. Either way, you learn about what other people like in a language, how deeply they feel so, and perhaps even a little about why they feel so. 参加语言的标准化工作。这可能是有关 ANSI C++ 委员会，也可能是缩进的风格是两格缩进或四格缩进。无论如何，你能从中学到其他人对语言的喜好，也能了解到他们热爱的程度，甚至也许能知道一点他们为什么他们会这样认为？ Have the good sense to get off the language standardization effort as quickly as possible. 知道何时能从标准化语言的工作中脱身，越快越好。 With all that in mind, its questionable how far you can get just by book learning. Before my first child was born, I read all the How To books, and still felt like a clueless novice. 30 Months later, when my second child was due, did I go back to the books for a refresher? No. Instead, I relied on my personal experience, which turned out to be far more useful and reassuring to me than the thousands of pages written by experts. 很难说能从书本中学到多少东西。我第一个小孩出生的时候，我读了所有的“如何做”系列的书，但是，没有什么头绪。30个月以后，当我的第二个孩子出生，我还要重温一下那些书么？当然不用了！我都已经是老司机了，我完全靠我自己的经验，事实也证明我自己的经验要胜过那些专家们写的上千页的书。 Fred Brooks, in his essay No Silver Bullet identified a three-part plan for finding great software designers: 弗雷德·布鲁克斯在他的书《没有银弹》中给出了三条建议： Systematically identify top designers as early as possible. 尽早地系统地识别出顶级设计师 Assign a career mentor to be responsible for the development of the prospect and carefully keep a career file. 每个人给分配一个职业规划的导师 Provide opportunities for growing designers to interact and stimulate each other. 让成长中的设计师有机会互相切磋武艺 This assumes that some people already have the qualities necessary for being a great designer; the job is to properly coax them along. Alan Perlis put it more succinctly: “Everyone can be taught to sculpt: Michelangelo would have had to be taught how not to. So it is with the great programmers”. Perlis is saying that the greats have some internal quality that transcends their training. But where does the quality come from? Is it innate? Or do they develop it through diligence? As Auguste Gusteau (the fictional chef in Ratatouille) puts it, “anyone can cook, but only the fearless can be great.” I think of it more as willingness to devote a large portion of one’s life to deliberative practice. But maybe fearless is a way to summarize that. Or, as Gusteau’s critic, Anton Ego, says: “Not everyone can become a great artist, but a great artist can come from anywhere.” 此处假设有一些人天生有成为伟大设计师的潜质，然后，就是正确的去引导他们。艾伦·佩里斯一针见血地说：”假如每个人都可以学会雕刻，那就得教米开朗基罗哪些事不要去做。对于伟大程序员，也是如此。”Perlis认为，伟大的人有一种内在的特质，这种特质往往比接受训练更重要。但是，这些特质是从哪里来的呢？与生俱来的？还是通过后天勤奋而来的？正如 动画片《料理鼠王》里的幻象大厨Auguste Gusteau说的那样：“谁都能做饭，但只有那些无所畏惧的人才能成为大厨！”我认为“把你生命中的大部分时间花在有针对性的练习上”这种精神，看作一种自愿奉献的精神！但或许“无所畏惧”才是体现这种精神的真谛。或者，就像是《料理鼠王》里那个与 Gusteau 作对的刻薄的美食评论家 Anton Ego 说的那样：“不是任何人都能成为伟大的艺术家，不过，伟大的艺术家可以来自任何地方。” So go ahead and buy that Java/Ruby/Javascript/PHP book; you’ll probably get some use out of it. But you won’t change your life, or your real overall expertise as a programmer in 24 hours or 21 days. How about working hard to continually improve over 24 months? Well, now you’re starting to get somewhere… 所以，尽管买本 Java/Ruby/Javascript/PHP 的书吧。你可能会从中学到点儿有用的东西。但作为一个程序员，在 21 天内或 24 小时内改变你的人生，或者提高你实际的编程水平，这是不可能的。你尝试过连续 24 个月不间断的努力提高自己么？好吧，好吧，你该上路了……]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么学生不喜欢上学]]></title>
    <url>%2F2018%2F12%2F24%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[为什么学生不喜欢上学 用你的梦想和理想引领你的一生，要用感恩真诚助人圆梦的心态引领你的一生，要用执着无惧乐观的态度引领你的一生。如果你做到了这些，因缘会给你一切你所应得的。 不要被信条所惑，盲从信条就是活在别人思考的结果里。不要让别人的意见淹没了你内在的心声。最重要的，拥有跟随内心与直觉的勇气，你的内心与直觉多少已经知道那你真正想要成为什么样的人，任何其他事物都是次要的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李开复自传]]></title>
    <url>%2F2018%2F12%2F24%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[价值不是你拥有多少,而是你留下多少. 用你的梦想和理想引领你的一生，要用感恩真诚助人圆梦的心态引领你的一生，要用执着无惧乐观的态度引领你的一生。如果你做到了这些，因缘会给你一切你所应得的。 不要被信条所惑，盲从信条就是活在别人思考的结果里。不要让别人的意见淹没了你内在的心声。最重要的，拥有跟随内心与直觉的勇气，你的内心与直觉多少已经知道那你真正想要成为什么样的人，任何其他事物都是次要的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>自传</tag>
      </tags>
  </entry>
</search>
